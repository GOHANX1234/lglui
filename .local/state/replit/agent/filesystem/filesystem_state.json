{"file_contents":{"README-MOBILE.md":{"content":"**This is for Android mobile users who do not have a PC. Floating apps or similar is recommended to read this page while working at the same time**\n\n**BEST VIEWED ON MOBILE!**\n\n# Quick links\n- [Prerequisites](https://github.com/LGLTeam/Android-Mod-Menu/blob/master/README.md#prerequisites)\n- [What you need](#what-you-need)\n- [Video Tutorial](#video-tutorial)\n- [Installation](#installation)\n- [Setting up AIDE](#setting-up-aide)\n- [Files to work with and making changes](#files-to-work-with-and-making-changes)\n- [Implementing the menu to the target game](#implementing-the-menu-to-the-target-game)\n- [FAQ](#faq)\n- [Troubleshooting](#troubleshooting)\n- [Credits/Acknowledgements](#creditsacknowledgements)\n\n# What you need\n* Modded AIDE app, choose one of them you like to use. The official AIDE from Play Store will not work with this project\n    * [AIDE CMODs](https://secufiles.com/nE9J/AIDE_CMODs_3.2.200108.apk)\n\t* [AIDE Lite Mod](https://mega.nz/file/bIpCQL6I#BzyLf1pB1Sf7EayW_PEJHl3f50qHHZDdb0BpB8FYdVo)\n* NDK support for modded AIDE\n    * NDK for 32-bit/ARMv7 phones: [ndk_arm.tar.gz](https://mega.nz/folder/2c1TWIJD#UCzO7kIo1e4WpFwZHIMYVw/file/XRlRTIjJ)\n    * NDK for 64-bit/ARM64 phones: [ndk_arm64.tar.gz](https://mega.nz/folder/2c1TWIJD#UCzO7kIo1e4WpFwZHIMYVw/file/7RdTzYxQ)\n* Any File Manager app you like to use but these are recommended\n    * [X-plore](https://play.google.com/store/apps/details?id=com.lonelycatgames.Xplore&hl=en): \n    * [MT Manager](https://bbs.binmt.cc/forum-2-1.html) [(Mirror link)](https://secufiles.com/js6i/MT2.9.2.apk) With build-in Apktool and editors to modify APK file. Note: It requires VIP to edit `AndroidManifest.xml` more than 200 lines\n* Apktool app to edit `AndroidManifest.xml` for free: [Modded APK Editor Pro app](https://mega.nz/file/zQxA0YDY#eNRgcyrHwpWh1nSTHhcc4quxzeXrXcUHlYPoRyltKEw) or [APK Repacker](https://mega.nz/file/LIom0DDL#hJyIchPDCk2n_gcDmutNsOKS86WXQN58qpEGa9JsLrU) (We use APK Editor Pro)\n* [Floating apps](https://play.google.com/store/apps/details?id=com.lwi.android.flappsfull&hl=en) (optional): You can use it to read this page and working at the same time or use a build-in feature by OEM\n\n# Video Tutorial\nNote: Videos may be quite outdated\n\nMahmoud Gaming: https://www.youtube.com/watch?v=SMCsUy60Hs8\n\nNSRAÎNA HACKER: https://www.youtube.com/watch?v=MkkZ_loEDTU\n\nBROKE MODS OFC (Customized menu): https://www.youtube.com/watch?v=IYREVGc-quM\n\n# Installation\n\nGo to releases page https://github.com/LGLTeam/Android-Mod-Menu/releases/ and download **Source code (zip)**\n\nTo download latest commit, enable desktop mode on your browser then click **Code**, and click **Download ZIP**\n\n![](https://i.imgur.com/EZnbd10.png)\n\n# Setting up AIDE\n\nNow let's begin\n\nFirstly, make sure you know your phone's hardware well, and download correct NDK file coresponding to your phone's architecture. ndk_arm.tar.gz for 32-bit/ARMv7 phones, ndk_arm64.tar.gz for 64-bit/ARM64 phones. Installing incorrect version will cause problems\n\nNow install NDK support for modded AIDE. Click on 3 dots on the right-corner. Click **More... - Settings**\n\n![](https://i.imgur.com/LyZMkK1.png)\n\nGo to **Build & Run**, and click on **Manage native code support**.\n\n![](https://images2.imgbox.com/6e/5c/DootVB4P_o.png)\n\nA prompt will ask to input the path of NDK file.\n\nIf you use X-plore, you can show details of the file and copy file path easly.\n\n![](https://images2.imgbox.com/54/2b/G0gVbhrN_o.png)\n\nPaste it in the prompt box.\n\n![](https://images2.imgbox.com/e1/c0/HSj9yQS9_o.png)\n\nClick install and wait\n\n![](https://images2.imgbox.com/1d/55/7LPXB7CI_o.png)\n\nAfter installiation, you can now use AIDE with NDK support\n\n# Opening project in AIDE\n\nOn the main screen, it says **No open files**. We simply click on **No open files** to show file explorer. Navigate to the directory of the project and open **app** folder\n\nAn option **Open Android app Project** will appear. Click on it to open\n\n![](https://images2.imgbox.com/dc/7f/Jtq8ZEl1_o.png)\n\nNow that the file explorer will look like this, means the project has been opened\n\n![](https://images2.imgbox.com/2f/9a/EA0zZr8R_o.png)\n\nPress play to compile the project whether it works or not\n\nIf successful, it will ask you to install the APK. It may ask you to allow installation from unknown sources. Please allow when asked\n\nOpen the app to test\n\n# Files to work with and making changes\n\nSee more: https://github.com/LGLTeam/Android-Mod-Menu#files-to-work-with-and-making-changes\n\nImportant for 32-bit users: Please remove arm64-v8a from application.mk\n\n# Implementing the menu to the target game\n\n### 1. Exporting to APK\n\nWe need to compile the project into APK file\n\nClick on 3 dots icon on the corner. **More... - Project - Publish project**\n\n![](https://images2.imgbox.com/e3/2b/8uBsyDwe_o.png)\n\nThis dialog will show but why is export greyed? Because you need to create your own keystore first. Click **Create keystore**\n\n![](https://images2.imgbox.com/ec/86/pQMmCpiN_o.png)\n\nThere is no need to put your organization info. Just your alias, password and name are fine. Don't forget your password!\n\nAfter you created your keystore, you can now export\n\n![](https://images2.imgbox.com/7c/4b/dkSUTXpx_o.png)\n\nEnter your keystore password\n\n![](https://images2.imgbox.com/3f/05/0Ois42P5_o.png)\n\nAfter that, it will tell you the APK has been experted\n\n![](https://images2.imgbox.com/4b/7b/GZuUcUOi_o.png)\n\n### 2. Downloading standalone APK from apkcombo\n\nIt is not a good idea to pull out installed APK from phone because sometimes it comes with splitted APKs, it's a dumb feature, we should use Apkcombo to download standalone APK\n\nTry to use armv7 standalone APK as possible. It support on all armv7, x86 and arm64 devices\n\nhttps://apkcombo.com/\n\n### 3. Know the game's main activity\n\nWe are looking for main activity. X-plore app can get main activity of the app so we will use that\n\nClick **Show**, check **App manager**.\n\n![](https://images2.imgbox.com/d9/f2/wFQs1Nwi_o.png)\n\nLong press on an app and click **Show details**, then click **App** and expand **Activity**\n\nHere we can see the main activity. It's always on top\n\n![](https://images2.imgbox.com/fd/e4/CQFS4fJJ_o.png)\n\nNote it down somewhere to remember it. We will explain this later\n\n### 4. Adding dex and lib file\n\nWe will use MT Manager to modify APK. Edit the files inside APK is pretty much straight forward, we do not need to decompile the whole APK to storage at all.\n\nOpen the APK file. Click **View** to show its content\n\n![](https://images2.imgbox.com/f6/6c/6xd8CxIa_o.png)\n\nYou will now see the content structure inside the APK\n\n![](https://images2.imgbox.com/68/b6/ejdGhu1M_o.png)\n\nDo the same on compiled mod menu APK on the other pane\n\nWe need to rename the dex on our mod menu APK to add dex into the game APK. We name it to classes2.dex since it contain only single dex. If the game have multiple dexes, like classes.dex, classes2.dex, classes3.dex, we would name it to classes4.dex. Mod menu dex must always be last\n\n![](https://images2.imgbox.com/2d/f2/0ySkQexV_o.png)\n\nPress and hold on our dex, and click **+ Add**. This dialog will show. Enable **Auto Sign**, leave Update mode **Replace All**\n\n![](https://images2.imgbox.com/42/94/6awBaOeG_o.png)\n\nClick OK, it will copy and auto sign.\n\nCopy your library file (.so file) too. Make sure to copy to the correct architecture\narmeabi-v7a is armeabi-v7a, arm64-v8a is arm64-v8a, and so on.\n\nPUTTING THE .SO file ON A WRONG ARCHITECTURE WILL RESULT IN A CRASH!\n\n![](https://images2.imgbox.com/34/93/NqI2kgOl_o.png)\n\n### 5. Making corresponding changes and compile\n\nOk, we go back to the main directory inside APK. You can press **..** to go back\n\n**I don't want to explain it here again, so please go to main README.md to read: https://github.com/LGLTeam/Android-Mod-Menu/blob/master/README.md#2-making-corresponding-changes-in-the-files**\n\n**Editing DEX file using MT Manager**\n\nOpen `classes.dex` directly, choose **Dex Editor Plus**\n\n![](https://images2.imgbox.com/d4/65/UlDjc5EY_o.png)\n\nThis dialog will show if it have multidex. **SELECT ALL** and click OK\n\n![](https://images2.imgbox.com/c3/65/3vpID6Um_o.png)\n\nThe editor opens.\n\nMake some changes. After you're done, save it\n\n![](https://images2.imgbox.com/ad/7c/JyAKmAwA_o.png)\n\nGo back and **save and exit**\n\n![](https://images2.imgbox.com/f2/a3/x0V6dgjH_o.png)\n\nClick OK to update the changes to the game's APK file with auto sign on\n\n![](https://images2.imgbox.com/1a/5a/4Dw9YFv9_o.png)\n\nGo back outside APK. You will now see a green text which tells you that you have recently modified the file\n\n![](https://images2.imgbox.com/dc/c3/SX5pHGPj_o.png)\n\n**Editing XML file using APK Editor Pro**\n\nMT Manage requires an account to edit `AndroidManifest.xml` and VIP account to edit more than 200 lines. No, we don't need VIP, we will use APK Editor Pro to edit\n\nOpen APK Editor Pro, click \"Select an Apk file\". Navigate to the location where you have stored APK, and select it to edit\n\n![](https://images2.imgbox.com/97/05/bIwx800E_o.png)\n\nOpen `AndroidManifest.xml`\n\n![](https://images2.imgbox.com/01/11/eP695bXz_o.png)\n\nMake some changes. After you're done, save it\n\n![](https://images2.imgbox.com/e4/e5/CgmEHFof_o.png)\n\nGo back, save the APK file\n\n![](https://images2.imgbox.com/ca/4d/0zeGiS91_o.png)\n\nWait until it finish compiling. This screen will show after it's done. You can choose to install the APK right now. You may need to uninstall original APK first\n\n![](https://images2.imgbox.com/30/3e/hNbeXhYr_o.png)\n\nIt's obvious that it saved an APK to the strange location `/storage/emulated/0/ApkEditor/tmp/gen_signed.apk`, just move it somewhere if you like to.\n\nIf it works, congratulations!\n\n# Troubleshooting\n\nProblem with the project like app crashes: click **More... -> Project -> Refresh Build**. This will clear the project cache and fix problems\n\nProblem with AIDE: Open System Settings -> Apps and clear data of AIDE app. This will reset everything and you need to install NDK again\n\nAIDE has a lot of compatibility issues, you need to research a lot and do some trial and errors until you fix something.\n\n# FAQ\n\nSee: https://github.com/LGLTeam/Android-Mod-Menu#faq\n\n# Credits/Acknowledgements\n\n* RAUNAK MODS for help in modding games via phone, and testing the template in AIDE","size_bytes":10284},"README.md":{"content":"**WARNING: THIS TEMPLATE IS NOT FOR NEWBIES, THIS IS FOR EXPERIENCES PROGRAMMERS ONLY. NEWBIES SHOULD NOT PROCEED TO TRY IT**\n\n**This won't cover how to mod games in general, hooking functions, etc that every other online tutorial already covers. This template simply tells you how to use them**\n\n**For Android mobile users who don't have a PC, please read [README-MOBILE.md](https://github.com/LGLTeam/Android-Mod-Menu/blob/master/README-MOBILE.md)**\n\n# KNOWN BUG\n- Spinner does not show on Android 11\n\n# Table of contents\n- [Prerequisites](https://github.com/LGLTeam/Android-Mod-Menu/blob/master/README.md#prerequisites)\n- [What you need](#what-you-need)\n- [Video Tutorial](#video-tutorial)\n- [Installation](#installation)\n- [Files to work with and making changes](#files-to-work-with-and-making-changes)\n- [Implementing the menu to the target game](#implementing-the-menu-to-the-target-game)\n- [Loading lib without mod menu](#loading-lib-without-mod-menu)\n- [Leeching concerns](#leeching-concerns)\n- [FAQ](#faq)\n- [Reporting issues/Cоntact](reporting-issuescоntact)\n- [Credits/Acknowledgements](#creditsacknowledgements)\n\n# Introduction\nFloating mod menu for il2cpp and other native android games, originally based on [VanHoevenTRs](https://platinmods.com/threads/template-menu-free-for-mod-menu-il2cpp-and-other-native-games.67429/), and some codes used from [Octowolve](https://github.com/Octowolve/Hooking-Template-With-Mod-Menu). KittyMemory, MSHook, And64InlineHook and AY Obfuscator included. Assets are stored as base64 in cpp and does not need to be stored under assets folder.\n\nSupport Android 4.4.x up to Android S Preview. ARMv7, x86 and ARM64 architecture supported. However x86 is deprecated for Unity games so x86 is not our priority\n\nPreview:\n\n![](https://i.imgur.com/zeumkBG.gif)\n\n# Prerequisites\nBefore we can jump head first into working a template, we need to go over a few things.\n\n* **AN EXPERIENCED MODDER, NOT A BEGINNER:** You should be able to mod any games in general, like modifying .so files, dll files, smali files, etc.\n* Basic knowledge of smali dalvik opcodes to modify smali\n* Basic knowledge ARM and ARM64 assembly, to be able to patch hex (No need x86)\n* Basic knowledge of C++ and java (JNI is optional)\n* Be able to write hook function in C++ (Not really needed, but recommended if you want to do advanced modding in the future)\n* Basic awareness of how Android layout works in XML and Java. This project only use Java for layout but you will learn it easly\n* Time and patience: Don't start working on this if you have deadlines or important work. Take your time to read, learn and get used to work with this project.\n* DIY (Do it yourself): Yes, you must be able to do things yourself, not depending being spoonfeed. We are not the teachers.\n* An inquisitive mind\n\n# What you need\n* Android Studio 4 and up: https://developer.android.com/studio\n* NDK Installed via Android Studio (Cmake is not needed) https://developer.android.com/studio/projects/install-ndk#default-version\n* Apktool: [Apktool.jar](https://ibotpeaches.github.io/Apktool/) or any 3rd party tools\n* [APK Easy Tool](https://forum.xda-developers.com/android/software-hacking/tool-apk-easy-tool-v1-02-windows-gui-t3333960). To get main activity: \n* Any text editor. We use [Notepad++](https://notepad-plus-plus.org/downloads/)\n* Any png compression to compress your png file: We use https://compresspng.com/\n* Any base64 encoding to encode your file: We use https://www.base64encode.org/\n* ARM converter, to convert ARM instruction to hex: https://armconverter.com/\n\n# Video Tutorial\nBig thanks to modders who created a video tutorial for me. Be warned, those videos might be outdated\n\nPMT DVA: https://www.youtube.com/watch?v=ieMclBtL6Ig\n\nPasha Production: https://www.youtube.com/watch?v=RvrZKIe-QGc\n\n# Installation\nDownload this repo as ZIP, or clone using any git tools\n\nOr download Releases here https://github.com/LGLTeam/Android-Mod-Menu/releases\n\nExtract the source to your desired location. The location must **NOT** contain any spaces or symbols\n\nOpen the project\n\nPlease wait for a while, it will index and sync the project for the first time, takes around a minute depending your computer performance\n\nAfter it's done, you can start working!\n\n# Files to work with and making changes\n\n#### **modmenu/Logcat.java**\nTo save and clear logcat on menu settings without root and without file permission. Can be helpful for modders to diagnose the issues\n\nAndroid 11: /storage/emulated/0/Documents/Mod Menu logs/\n\nAndroid 10 and below: /storage/emulated/0/Android/data/(package name)/files/Mod Menu logs\n\n#### **modmenu/Preferences.java**\n\nSaving the menu feature preferences and calling changes via JNI\n\n#### **modmenu/FloatingModMenuService.java**\n\nMain codes of floating mod menu design\n\nYou don't need to change unless you want to redesign it. The codes are explained in the comments\n\n- `GradientDrawable`: A code for setting corner and stroke/inner border. Works for any View Components\n\n```java\nGradientDrawable gradientdrawable = new GradientDrawable();\ngradientdrawable.setCornerRadius(20); //Set corner\ngradientdrawable.setColor(Color.parseColor(\"#1C2A35\")); //Set background color\ngradientdrawable.setStroke(1, Color.parseColor(\"#32cb00\")); //Set border\n```\n\nSet the gradient drawable to the view component\n\n```java\n[name of your view component].setBackground(gradientdrawable);\n```\n\n- Resizing menu box\n\nI've added variables so you can find it easly to resize\n\n```java\nprivate final int MENU_WIDTH = 290;\nprivate final int MENU_HEIGHT = 200;\n```\n\nNote: You may need to implement auto sizing due to many types of phone with different DPIs and resolutions\n\n- Color Animation: The codes can be seen in `startAnimation()`\n\n- Adding new view\n\nNormally the Android development documentation does not explain the code in java. If you read the Android development documentation and you see an example like TextView\n\n```java\nTextView textView = (TextView) findViewById(R.id.textView);\ntextView.setFontVariationSettings(\"'wdth' 150\");\n```\n\nThis is for xml. Instead, create an instance for java and add view to your Layout\n\n```java\nTextView textView = new TextView(this);\ntextView.setFontVariationSettings(\"'wdth' 150\");\nLinearLayoutExample.addView(textView);\n```\n\nWhile we can't explain much here, you can use Google. Search like `create a textview programmatically android`, `create a button programmatically android` etc. for more infomation\n\n#### **MainActivity.java**\n\nThe Main Activity. Checks if device running Android 6.0 or above and if have overlay permission enabled before starting menu service.\n\nYou pretty don't need to work with it unless you are implementing something like login layout.\n\n#### **jni/Menu.h**\n\nMenu related with JNI calls\n\n- `Title`: Big text\n\n- `Heading`: Little text. Semi HTML is supported. Text will scroll if the text is too long\n\n- `Icon`: Compressed image that is encoded to base64\n\nYou can pretty much use any tools for base64 encoding.\n\nWe use a simple website https://www.base64encode.org/\n\nScroll down till you see `Encode files into Base64 format`. Click or tap on the box to select a file\n\nClick on `ENCODE` button and click on `CLICK OR TAP HERE` to download your encoded file. Now you can paste it in cpp code\n\n- `IconWebViewData`: Use icon in Web view with GIF animation support. URL requires internet permission `android.permission.INTERNET`\n\nExamples\n\n```cpp\n//From internet: (Requires android.permission.INTERNET)\nreturn env->NewStringUTF(\"https://i.imgur.com/SujJ85j.gif\"); \n\n//From assets folder: (Requires android.permission.INTERNET)\nreturn env->NewStringUTF(\"file:///android_asset/example.gif\"); \n\n//Base64 html:\nreturn env->NewStringUTF(\"data:image/png;base64, <encoded base64 here>\");\n\n//Nothing:\nreturn NULL\n```\n\n- `settingsList`: Feature list for settings\n\n#### **jni/Main.cpp**\n\nIn this file, you will work with your mods. Below `hack_thread`, you write your code to patch with KittyMemory or hook with MShook. You must have learned it already\n\nIt has a macro to detect if the ARM architecture is 32-bit or 64-bit on compile-time, it's to avoid using wrong offsets, like using ARMv7 offsets on an ARM64 lib. Check the game's APK what libs it contains before you proceed. If you want to target armeabi-v7a lib, write the code below `#else`. If you want to target arm64-v8a libs, write the code below `#if defined(__aarch64__)`. If the game has both armeabi-v7a and arm64-v8a, save your time and delete arm64-v8a folder, only target on armv7. Don't worry, the game will still work on ARM64\n\nWe know we could do `#if defined(__arm__)` for ARMv7 and `#if defined(__i386__)` for x86, but we will leaving `#else`, so AS doesn't make that part greyed out. We will still using ARMv7 as a primary target\n\n- `Changes`: Get values to apply mods. BE CAREFUL NOT TO ACCIDENTLY REMOVE break;\n\n- `settingsList`: Settings assigned in negative numbers, we keep the positive numbers for mods. Works same as mod features but the call must be implemented in `localChanges(int featureNum, boolean toggle)` in `FloatingModMenuService.java`\n\n- `getFeatureList`: Mod features\n\nAssigning feature numbers is optional. Without it, it will automatically count for you, starting from 0\n\nAssigned feature numbers can be like any numbers 1,3,200,10... instead in order 0,1,2,3,4,5...\n\nDo not change or translate the first text unless you know what you are doing\n\nToggle, ButtonOnOff and Checkbox can be switched on by default, if you add `True_`. Example: `CheckBox_True_The Check Box`\n\nTo learn HTML, go to this page: https://www.w3schools.com/\n\nUsage:\n\n```cpp\n(Optional feature number)_Toggle_(feature name)\n(Optional feature number)_True_Toggle_(feature name)\n(Optional feature number)_SeekBar_(feature name)_(min value)_(max value)\n(Optional feature number)_Spinner_(feature name)_(Items e.g. item1,item2,item3)\n(Optional feature number)_Button_(feature name)\n(Optional feature number)_ButtonOnOff_(feature name)\n(Optional feature number)_InputValue_(feature name)\n(Optional feature number)_CheckBox_(feature name)\n(Optional feature number)_RadioButton_(feature name)_(Items e.g. radio1,radio2,radio3)\nRichTextView_(Text with limited HTML support)\nRichWebView_(Full HTML support)\nButtonLink_(feature name)_(URL/Link here)\nCategory_(text)\n```\n\nTo add a collapse, create a new instance\n```cpp\nCollapse_The collapse 1\n```\n\nThen you can add component views to collapse like\n\n```cpp\nCollapseAdd_Toggle_The toggle\n123_CollapseAdd_Toggle_The toggle\nCollapseAdd_Button_The button\n```\n\n#### KittyMemory patching usage:\n```cpp\nMemoryPatch::createWithHex([Lib Name], [offset], \"[hex. With or without spaces]\");\n[Struct].get_CurrBytes().Modify();\n[Struct].get_CurrBytes().Restore();\n\n[Struct].get_TargetAddress();\n[Struct].get_PatchSize();\n[Struct].get_CurrBytes().c_str();\n\nPATCHOFFSET(\"0x20D3A8\", \"00 00 A0 E3 1E FF 2F E1\");\nPATCHOFFSET_LIB(\"libFileB.so\", \"0x20D3A8\", \"00 00 A0 E3 1E FF 2F E1\");\n```\n\nExample: https://github.com/MJx0/KittyMemory/blob/master/Android/test/src/main.cpp\n\nUse an online ARM assembly converter like ARMConverter to convert ARM to HEX: https://armconverter.com/\n\n#### Hook usage:\nThis macro works for both ARMv7 and ARM64. Make sure to use predefined macro `defined(__aarch64__)` and `defined(__arm__)` if you are targeting both archs\n\nStrings for macros are automatically obfuscated. No need to obfuscate!\n```cpp\nHOOK(\"0x123456\", FunctionExample, old_FunctionExample);\nHOOK_LIB(\"libFileB.so\", \"0x123456\", FunctionExample, old_FunctionExample);\nHOOK_NO_ORIG(\"0x123456\", FunctionExample);\nHOOK_LIB_NO_ORIG(\"libFileC.so\", \"0x123456\", FunctionExample);\nHOOKSYM(\"__SymbolNameExample\", FunctionExample, old_FunctionExample);\nHOOKSYM_LIB(\"libFileB.so\", \"__SymbolNameExample\", FunctionExample, old_FunctionExample);\nHOOKSYM_NO_ORIG(\"__SymbolNameExample\", FunctionExample);\nHOOKSYM_LIB_NO_ORIG(\"libFileB.so\", \"__SymbolNameExample\", FunctionExample);\n```\n\nOr\n\nARM64:\n```cpp\nA64HookFunction((void *) getAbsoluteAddress([Lib Name], [offset]), (void *)[function], (void **)&[old function]);\n```\n\nARMv7/x86:\n```cpp\nMSHookFunction((void *) getAbsoluteAddress([Lib Name], [offset]), (void *)[function], (void **)&[old function]);\n```\n\n#### **Android.mk**\n\nThe make file for the c++ compiler. In that file, you can change the lib name on the `LOCAL_MODULE` line\nWhen you change the lib name, change also on `System.loadLibrary(\"\")` under OnCreate method on `MainActivity.java`\nBoth must have same name\n\n# Testing\n\nConnect your device to the computer or run your emulator. Android Studio will detect and you can click Play to run your app.\n\n![](https://i.imgur.com/ZegjeM8.png)\n\nOn physical device, make sure you have USB-Debugging enabled in the developer option of your device. To make it visible, go to **Settings** > **About phone** and tap Build number seven times. Return to the previous screen to find Developer options at the bottom. The Developer options screen might be located or named differently on some devices\n\nSometimes Android Studio does not detect emulators such as NOX or MEMU fail to connect to adb automatically, reboot can help sometimes. Please refer to the support page.\n\n# Implementing the menu to the target game\n\n### 1. Know your game's main activity\n\nNow we are looking for main activity, there are 2 ways to do\n\n1. Decompile the game's APK file. Open `AndroidManifest.xml` and search after `<action android:name=\"android.intent.action.MAIN\"/>`.\n\nExample the game's main activity was `com.unity3d.player.UnityPlayerActivity`\n\n![](https://i.imgur.com/FfOtc1K.png)\n\nBe sure to enable Word wrap so it is easier to read\n\n![](https://i.imgur.com/7DzU8d0.png)\n\n2. APK Easy Tool since it can read out location of main activity without decompiling APK\n\n![](https://i.imgur.com/JQdPjyZ.png)\n\nNote it somewhere to remember it\n\n### 2. Making corresponding changes in the files\n\nDecompile the game APK\n\nOpen the game's `AndroidManifest.xml`\n\nAdd the `SYSTEM_ALERT_WINDOW` permission besides other permissions if it doesn't exist. Doesn't matter where you place it as long as it's above the application tag\n```xml\n<uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\"/>\n```\n\nIf you don't add it, you can't allow overlay permission.\n\n![](https://i.imgur.com/XOxLU91.png)\n\nAdd the service above the end of application tag (change the package name of your menu if you had changed it)\n```xml\n<service android:name=\"uk.lgl.modmenu.FloatingModMenuService\" android:enabled=\"true\" android:exported=\"false\" android:stopWithTask=\"true\"/>\n```\n\n![](https://i.imgur.com/rw0hawa.png)\n\nNow we need to call your mod menu activity\n\nThere are 2 ways to call your mod menu activity. Choose one of them you like to try. Don't know? just choose METHOD 1\n\n**METHOD 1**\n\nThis simple way, we will call to `MainActivity.java`. `MainActivity.java` will never be used\n\nLocate to the game's path of main activity and open the **smali** file. If the game have multi dexes, it may be located in smali_classes2.. please check all\n\nWith the path of the target game’s main activity which we determined earlier `com.unity3d.player.UnityPlayerActivity`. Think of it like a path `/com/unity3d/player/UnityPlayerActivity.smali`\n\nOpen the main acitivity's smali file, search for OnCreate method and paste this code inside (change the package name if you had changed it)\n```\ninvoke-static {p0}, Luk/lgl/MainActivity;->Start(Landroid/content/Context;)V\n```\n \n![](https://i.imgur.com/7CxTCl8.png)\n\nSave the file\n\n**METHOD 2**\n\nYou can follow this it if the first method really fails, or if you really want to use `MainActivity.java` for a reason. Since this involve changing activites, it may cause some problems.\n\nOn your `MainActivity.java`, put the game's main activity to `public String GameActivity`\n\n![](https://i.imgur.com/jdacwvH.png)\n\nUncomment this code\n\n```\nToast.makeText(MainActivity.this, \"Error. Game's main activity does not exist\", Toast.LENGTH_LONG).show();\n```\n\nOn `AndroidManifest.xml`, remove `<action android:name=\"android.intent.action.MAIN\"/>` from the game's activity, like this:\n\n![](https://i.imgur.com/z1RxPjc.png)\n\nIf you don't remove `<action android:name=\"android.intent.action.MAIN\"/>` from the game's activity, your menu will not launch. `AndroidManifest.xml` can ONLY contain one `<action android:name=\"android.intent.action.MAIN\"/>`\n\nnear the end of application tag `</application>`, add your main activity above it. `uk.lgl.MainActivity` is your main activity\n\n```xml\n<activity android:configChanges=\"keyboardHidden|orientation|screenSize\" android:name=\"uk.lgl.MainActivity\">\n     <intent-filter>\n         <action android:name=\"android.intent.action.MAIN\"/>\n         <category android:name=\"android.intent.category.LAUNCHER\"/>\n     </intent-filter>\n</activity>\n```\n\n![](https://i.imgur.com/33lMPhc.png)\n\nSave the file\n\n_Do NOT use both methods at the same time_\n\n### 3. Building your project and copying files\n\nBuild the project to the APK file.\n**Build** -> **Build Bundle(s)/APK(s)** -> **Build APK(s)**\n\nIf no errors occured, you did everything right and build will succeded. You will be notified that it build successfully\n\n![](https://i.imgur.com/WpSKV1L.png)\n\nClick on **locate** to show you the location of **build.apk**. It is stored at `(your-project)\\app\\build\\outputs\\apk\\app-debug.apk`\n\n![](https://i.imgur.com/wBTPSLi.png)\n\nDecompile your **app-debug.apk**.\n\nCopy your mod menu from decompiled app-debug.apk smali to the game's smali folder. Example ours is uk.lgl.modmenu, we copy the `uk` folder from **app-debug** `(app-debug\\smali\\uk)` to the game's decompiled directory `(game name)\\smali`\n\n![](https://i.imgur.com/aO6eEab.png)\n \nIf the game have multidexes, just add your smali to the last `smali_classes` if possible to prevent compilation errors such as `Unsigned short value out of range: xxxxx` (Smali limit error)\n\nCopy the library file (.so) from **app-debug.apk** to the target game. Watch out the folder names, we don't want to mix them up, so make sure to copy our lib file to the correct architecture. Like our armeabi-v7a lib goes to the target games armeabi-v7a folder, arm64-v8a lib goes to the arm64-v8a folder...\n\nPUTTING THE LIB FILE ON A WRONG ARCHITECTURE LIKE PUTTING ARM64 LIB TO ARMV7 WILL RESULT A CRASH!\n \n![](https://i.imgur.com/oZq1Wq7.png)\n \n### 4. Compiling game apk\n \nNow compile and sign the apk, and install it on your device\n\nCongrats. You have successfully implemented a mod menu.\n\nCompile failed? read the log and look up on Google\n\nIf you face any problem, please read the [FAQ](#faq)\n\n# Leeching concerns\n\nLeeching as known as stealing code and offsets via reverse enginnering, and editing credits via file editing and recompiling. We all know that, right?\n\nThere are some simple protections in the template:\n- Simple C++ string obfuscation called AY Obfuscator. Usage `OBFUSCATE(\"string here\")` and with a key `OBFUSCATE_KEY(\"string here\", 64-bit key here)`. Example `OBFUSCATE_KEY(\"Hello\", 2353474243)` or in hex `OBFUSCATE_KEY(\"Hello\", 0x3FE63DF21A3B)`. The key must not be too long or too short\n- `string2Offset(\"\")` to protect offsets\n- Simple anti-leech measures that crashes if JNI functions are not called\n- Quite harder to edit credits via smali\n- Toast hidden inside `getFeatureList` in Main.cpp\n\nThese protection are NOT full protection, it does not stop them, it will only slow them down, this intent is to help you improve on your own by yourself. You should:\n- Improve anti-leech measures on your own way\n- Protect and encrypt your dex and lib. Find the tools or the projects by yourself, chinese based tools is not recommended as anti virus may flag your mod for malware (false positive). Don't tell anyone what protection you are using, don't let game developers get a hand of it\n- Improve string obfuscators a lot more or use others which are not known. Make sure that obfuscator is not too simple\n- Enable proguard, and add filters to make sure it does not break your project. See https://developer.android.com/studio/build/shrink-code\n- Never share your project to someone\n- Do not include any important stuff such as 'offline' username and password, instead add an additional layer, e.g. a web service handling the protected request\n- And etc.\n\nNever contact how to protect more, never complain that your mod has been leeched, that's all your responsibility! If you are really worry about leeching, or getting constantly leeched, and can't protect, just upload your project on Github. They will download from your Github instead leeching.\n\n**Never tell us how to leech stuff, we are not interested getting involved in it, You will get blocked immediately!**\n\n# FAQ\n### My game crashing or freezing/My mod menu does not work\nThere are many many reasons why, it could be your code fault, wrong offsets, bad c++ code, bad layout implementations, game protections etc.\n\nThis is very hard to diagnose. Check logcat on Android Studio to see the error logs, open **Logcat** window from below, and select your device, process and filter to **Error**. Once you do, you can see the errors in logcat\n\n![](https://i.imgur.com/cutKC29.png)\n\nError on Java side is really easy to spot, if an the error occured natively, a huge `CRASH` report will be logged but it can be hard to figure out. You would have to dig deeper and figure out yourself. Google it if possible.\n\nIf that caused by your hacks, check if your patches and hooks are correct. For hooks, write down the logs such as `LOGD(\"whatever\");` like this below:\n\n```cpp\nbool get_BoolExample(void *instance) {\n    LOGD(\"Bool step 1\");\n    if (instance != NULL && featureHookToggle) {\n        LOGD(\"Bool step 2\");\n        return true;\n    }\n    LOGD(\"Bool step 3\");\n    return old_get_BoolExample(instance);\n}\n```\n\nThis can help you what part of your code faced the problem.\n\nIf you believe the game has protection, bypass it or drop it!\n\nSee more about logcat: https://developer.android.com/studio/debug/am-logcat\n\n### I have a problem decompiling or compiling APK file\nSearch for the related issues on Google or on Apktool Github page: https://github.com/iBotPeaches/Apktool/issues\n\n### I'm getting an error `Unsigned short value out of range: 65536` if I compile\nThe method index can't fit into an unsigned 16-bit value, means you have too many methods in the smali due to the limit 65535. Place your code on other classes, such as smali_classes2 instead. This work for Android 5 (Lollipop) and above only.\n\n### I'm getting an error `ERROR: executing external native build for ndkBuild Android.mk. Affected Modules: app`\nSee: https://github.com/LGLTeam/Android-Studio-Solutions/wiki/Executing-external-native-build-for-ndkBuild-Android.mk\n\n### I'm getting strange issues on Android Studio or Gradle\nSee: https://github.com/LGLTeam/Android-Studio-Solutions/wiki\n\n### How to get older version of the template? or how to see updates/commits?\n\nGo to the commit page https://github.com/LGLTeam/Android-Mod-Menu/commits/master\n\n### Why can't you just add the feature I want? For example closing animation?\n\nAlso known as: \"You're a developer after all — it shouldn't be that hard!\"\n\nSince we can't spend my days on it, we have to prioritize the features and fixes that are likely to benefit the larger number of people. Features that is specific to your usage is not going to benefit that many users after all. This is important that you do not expect that anyone can do everything for you. Developing *is* hard, and even outside of supporting a feature, adding the code can take longer than you think!\n\nWith all this being said, remember that this is 100% Open Source. So if you really want a specific feature, try to do it yourself, or ask someone who are willing to help you.\n\n### Why can't you just help or teach me modding the game? For example, hooking?\n\nAnything else, such as how to hook, how to patch, how to bypass, what functions to mod, how il2cpp works, etc. is out of scope. We will not cover anything and trivial stuff every other tutorial online already covers. Instead, try to find a couple of tutorials to learn and mod the game yourself. It's a lot easier than you think. If you can't, find a couple of forums where you can ask your questions or ask the right modder for specific special features\n\n### When there is a new update? I have waited for so long time\n\nThere is no ETA, we only push a commit when we want to. Please don't ask the same question over and over again. You could make something better yourself without having to wait\n\n# Reporting issues/Cоntact\n<details>\n<summary>Cоntact:</summary>\nPlease stop and read this carefully.\n\nMake sure you have readed FAQ and at least searching for answers.\n\nIf you have usage problems, try asking your questions on any forum sites. For example, if you have an issue with hooking or patching, bypassing security, or wanna mod PUBG and Free Fire, you should go to the **forums**. Here there are no teachers, or who deal with such issues.\n\nBeginner/newbie/noobs and toxic peoples are **NOT** allowed to cоntact. They are annoying, you would be left **unanswered** and possibly get **BLOCKED**. Known leechers will be instant **BLOCKED**\n\nIssue tracker is permanently disabled\n\nTеlеgram: @ThеᒪGᒪ\n\nDisсоrd: Deleted because its community has become more toxic, and its security are bad\n\nYou can find @ThеᒪGᒪ on some forum modding communities\n</details>\n\n# Credits/Acknowledgements\nThanks to the following individuals whose code helped me develop this mod menu\n\n* Octowolve/Escanor - Mod menu: https://github.com/z3r0Sec/Substrate-Template-With-Mod-Menu and Hooking: https://github.com/z3r0Sec/Substrate-Hooking-Example\n* VanHoevenTR - Mod menu - https://github.com/LGLTeam/VanHoevenTR_Android_Mod_Menu\n* MrIkso - First mod menu template https://github.com/MrIkso/FloatingModMenu\n* MJx0 A.K.A Ruit - https://github.com/MJx0/KittyMemory\n* Rprop - https://github.com/Rprop/And64InlineHook\n* And everyone else who provided input and contributions to this project!","size_bytes":25929},"replit.md":{"content":"# Android Mod Menu Template\n\n## Overview\n\nThis project is a comprehensive template for creating floating mod menus for Android games, specifically targeting native games and il2cpp Unity games. It provides a framework for experienced modders to implement custom modification interfaces that overlay on top of target applications. The template supports multiple Android versions (4.4.x to Android S Preview) and architectures (ARMv7, ARM64, and x86), making it versatile for various mobile gaming environments.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Core Architecture\n- **Native Library Framework**: Built using C/C++ with JNI (Java Native Interface) for Android integration\n- **Cross-Architecture Support**: Supports ARMv7, ARM64, and x86 architectures with focus on ARM variants\n- **Overlay UI System**: Implements floating overlay menus that can be displayed on top of target applications\n- **Hook Integration**: Utilizes And64InlineHook library for ARM64 inline hooking capabilities\n\n### Development Environment\n- **Android Studio Integration**: Designed to work with Android Studio 4+ with NDK support\n- **Mobile Development Option**: Alternative setup using modded AIDE apps for on-device development\n- **Build System**: Uses standard Android build tools with native library compilation support\n\n### UI Architecture\n- **Java-based Layout**: UI components implemented in Java with XML layout definitions\n- **Floating Window System**: Leverages Android's overlay permission system for floating interfaces\n- **Cross-Platform Compatibility**: Designed to work across different Android versions and screen sizes\n\n### Hook System\n- **And64InlineHook Library**: Lightweight ARM64 inline hooking for function interception\n- **Multi-Architecture Support**: Separate implementations for different processor architectures\n- **Memory Manipulation**: Direct memory access and modification capabilities for game patching\n\n## External Dependencies\n\n### Development Tools\n- **Android Studio**: Primary IDE with NDK support for native development\n- **Apktool**: APK decompilation and recompilation tool for target game modification\n- **APK Easy Tool**: GUI wrapper for APK manipulation tasks\n\n### Mobile Development Dependencies\n- **Modded AIDE Apps**: Alternative IDEs for mobile-only development workflows\n- **NDK Packages**: Architecture-specific Native Development Kit packages\n- **File Management Apps**: X-plore or MT Manager for file system operations\n\n### Runtime Dependencies\n- **Android Overlay Permissions**: System-level permissions for floating UI display\n- **Native Library Loading**: Android's native library loading mechanism\n- **JNI Bridge**: Java Native Interface for communication between Java UI and C++ core\n\n### Target Integration\n- **Game Process Injection**: Capability to inject into target application processes\n- **Memory Access**: Direct memory read/write operations on target applications\n- **Function Hooking**: Runtime interception and modification of game functions","size_bytes":3055},"app/src/main/jni/Android.mk":{"content":"LOCAL_PATH := $(call my-dir)\nMAIN_LOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\n\n# Here is the name of your lib.\n# When you change the lib name, change also on System.loadLibrary(\"\") under OnCreate method on StaticActivity.java\n# Both must have same name\nLOCAL_MODULE    := MyLibName\n\n# Code optimization\n# -std=c++17 is required to support AIDE app with NDK\nLOCAL_CFLAGS := -Wno-error=format-security -fvisibility=hidden -ffunction-sections -fdata-sections -w\nLOCAL_CFLAGS += -fno-rtti -fno-exceptions -fpermissive\nLOCAL_CPPFLAGS := -Wno-error=format-security -fvisibility=hidden -ffunction-sections -fdata-sections -w -Werror -s -std=c++17\nLOCAL_CPPFLAGS += -Wno-error=c++11-narrowing -fms-extensions -fno-rtti -fno-exceptions -fpermissive\nLOCAL_LDFLAGS += -Wl,--gc-sections,--strip-all, -llog\nLOCAL_ARM_MODE := arm\n\nLOCAL_C_INCLUDES += $(MAIN_LOCAL_PATH)\n\n# Here you add the cpp file\nLOCAL_SRC_FILES := Main.cpp \\\n\tSubstrate/hde64.c \\\n\tSubstrate/SubstrateDebug.cpp \\\n\tSubstrate/SubstrateHook.cpp \\\n\tSubstrate/SubstratePosixMemory.cpp \\\n\tSubstrate/SymbolFinder.cpp \\\n\tKittyMemory/KittyMemory.cpp \\\n\tKittyMemory/MemoryPatch.cpp \\\n    KittyMemory/MemoryBackup.cpp \\\n    KittyMemory/KittyUtils.cpp \\\n\tAnd64InlineHook/And64InlineHook.cpp \\\n\nLOCAL_LDLIBS := -llog -landroid -lGLESv2\n\ninclude $(BUILD_SHARED_LIBRARY)\n","size_bytes":1318},"app/src/main/jni/Application.mk":{"content":"# To AIDE Users: If you are using 32-bit/ARMv7 phone, please remove arm64-v8a\nAPP_ABI := armeabi-v7a arm64-v8a x86\n# APP_PLATFORM := android-18 #APP_PLATFORM does not need to be set. It will automatically defaulting\nAPP_STL := c++_static\nAPP_OPTIM := release\nAPP_THIN_ARCHIVE := true\nAPP_PIE \t\t:= true\n","size_bytes":302},"app/src/main/jni/Main.cpp":{"content":"#include <list>\n#include <vector>\n#include <string.h>\n#include <pthread.h>\n#include <cstring>\n#include <jni.h>\n#include <unistd.h>\n#include <fstream>\n#include <iostream>\n#include <dlfcn.h>\n#include \"Includes/Logger.h\"\n#include \"Includes/obfuscate.h\"\n#include \"Includes/Utils.h\"\n\n#include \"KittyMemory/MemoryPatch.h\"\n#include \"Menu.h\"\n\n//Target lib here\n#define targetLibName OBFUSCATE(\"libFileA.so\")\n\n#include \"Includes/Macros.h\"\n\n// fancy struct for patches for kittyMemory\nstruct My_Patches {\n    // let's assume we have patches for these functions for whatever game\n    // like show in miniMap boolean function\n    MemoryPatch GodMode, GodMode2, SliderExample;\n    // etc...\n} hexPatches;\n\nbool feature1, feature2, featureHookToggle, Health;\nint sliderValue = 1, level = 0;\nvoid *instanceBtn;\n\n// Hooking examples. Assuming you know how to write hook\nvoid (*AddMoneyExample)(void *instance, int amount);\n\nbool (*old_get_BoolExample)(void *instance);\nbool get_BoolExample(void *instance) {\n    if (instance != NULL && featureHookToggle) {\n        return true;\n    }\n    return old_get_BoolExample(instance);\n}\n\nfloat (*old_get_FloatExample)(void *instance);\nfloat get_FloatExample(void *instance) {\n    if (instance != NULL && sliderValue > 1) {\n        return (float) sliderValue;\n    }\n    return old_get_FloatExample(instance);\n}\n\nint (*old_Level)(void *instance);\nint Level(void *instance) {\n    if (instance != NULL && level) {\n        return (int) level;\n    }\n    return old_Level(instance);\n}\n\nvoid (*old_FunctionExample)(void *instance);\nvoid FunctionExample(void *instance) {\n    instanceBtn = instance;\n    if (instance != NULL) {\n        if (Health) {\n            *(int *) ((uint64_t) instance + 0x48) = 999;\n        }\n    }\n    return old_FunctionExample(instance);\n}\n\n// we will run our hacks in a new thread so our while loop doesn't block process main thread\nvoid *hack_thread(void *) {\n    LOGI(OBFUSCATE(\"pthread created\"));\n\n    //Check if target lib is loaded\n    do {\n        sleep(1);\n    } while (!isLibraryLoaded(targetLibName));\n\n    //Anti-lib rename\n    /*\n    do {\n        sleep(1);\n    } while (!isLibraryLoaded(\"libYOURNAME.so\"));*/\n\n    LOGI(OBFUSCATE(\"%s has been loaded\"), (const char *) targetLibName);\n\n#if defined(__aarch64__) //To compile this code for arm64 lib only. Do not worry about greyed out highlighting code, it still works\n    // New way to patch hex via KittyMemory without need to  specify len. Spaces or without spaces are fine\n    // ARM64 assembly example\n    // MOV X0, #0x0 = 00 00 80 D2\n    // RET = C0 03 5F D6\n    hexPatches.GodMode = MemoryPatch::createWithHex(targetLibName,\n                                                    string2Offset(OBFUSCATE(\"0x123456\")),\n                                                    OBFUSCATE(\"00 00 80 D2 C0 03 5F D6\"));\n    //You can also specify target lib like this\n    hexPatches.GodMode2 = MemoryPatch::createWithHex(\"libtargetLibHere.so\",\n                                                     string2Offset(OBFUSCATE(\"0x222222\")),\n                                                     OBFUSCATE(\"20 00 80 D2 C0 03 5F D6\"));\n\n    // Hook example. Comment out if you don't use hook\n    // Strings in macros are automatically obfuscated. No need to obfuscate!\n    HOOK(\"str\", FunctionExample, old_FunctionExample);\n    HOOK_LIB(\"libFileB.so\", \"0x123456\", FunctionExample, old_FunctionExample);\n    HOOK_NO_ORIG(\"0x123456\", FunctionExample);\n    HOOK_LIB_NO_ORIG(\"libFileC.so\", \"0x123456\", FunctionExample);\n    HOOKSYM(\"__SymbolNameExample\", FunctionExample, old_FunctionExample);\n    HOOKSYM_LIB(\"libFileB.so\", \"__SymbolNameExample\", FunctionExample, old_FunctionExample);\n    HOOKSYM_NO_ORIG(\"__SymbolNameExample\", FunctionExample);\n    HOOKSYM_LIB_NO_ORIG(\"libFileB.so\", \"__SymbolNameExample\", FunctionExample);\n\n    // Patching offsets directly. Strings are automatically obfuscated too!\n    PATCHOFFSET(\"0x20D3A8\", \"00 00 A0 E3 1E FF 2F E1\");\n    PATCHOFFSET_LIB(\"libFileB.so\", \"0x20D3A8\", \"00 00 A0 E3 1E FF 2F E1\");\n\n    AddMoneyExample = (void(*)(void *,int))getAbsoluteAddress(targetLibName, 0x123456);\n\n#else //To compile this code for armv7 lib only.\n    // New way to patch hex via KittyMemory without need to specify len. Spaces or without spaces are fine\n    // ARMv7 assembly example\n    // MOV R0, #0x0 = 00 00 A0 E3\n    // BX LR = 1E FF 2F E1\n    hexPatches.GodMode = MemoryPatch::createWithHex(targetLibName, //Normal obfuscate\n                                                    string2Offset(OBFUSCATE(\"0x123456\")),\n                                                    OBFUSCATE(\"00 00 A0 E3 1E FF 2F E1\"));\n    //You can also specify target lib like this\n    hexPatches.GodMode2 = MemoryPatch::createWithHex(\"libtargetLibHere.so\",\n                                                     string2Offset(OBFUSCATE(\"0x222222\")),\n                                                     OBFUSCATE(\"01 00 A0 E3 1E FF 2F E1\"));\n\n    // Hook example. Comment out if you don't use hook\n    // Strings in macros are automatically obfuscated. No need to obfuscate!\n    HOOK(\"str\", FunctionExample, old_FunctionExample);\n    HOOK_LIB(\"libFileB.so\", \"0x123456\", FunctionExample, old_FunctionExample);\n    HOOK_NO_ORIG(\"0x123456\", FunctionExample);\n    HOOK_LIB_NO_ORIG(\"libFileC.so\", \"0x123456\", FunctionExample);\n    HOOKSYM(\"__SymbolNameExample\", FunctionExample, old_FunctionExample);\n    HOOKSYM_LIB(\"libFileB.so\", \"__SymbolNameExample\", FunctionExample, old_FunctionExample);\n    HOOKSYM_NO_ORIG(\"__SymbolNameExample\", FunctionExample);\n    HOOKSYM_LIB_NO_ORIG(\"libFileB.so\", \"__SymbolNameExample\", FunctionExample);\n\n    // Patching offsets directly. Strings are automatically obfuscated too!\n    PATCHOFFSET(\"0x20D3A8\", \"00 00 A0 E3 1E FF 2F E1\");\n    PATCHOFFSET_LIB(\"libFileB.so\", \"0x20D3A8\", \"00 00 A0 E3 1E FF 2F E1\");\n\n    AddMoneyExample = (void (*)(void *, int)) getAbsoluteAddress(targetLibName, 0x123456);\n\n    LOGI(OBFUSCATE(\"Done\"));\n#endif\n\n    return NULL;\n}\n\n//JNI calls\nextern \"C\" {\n\n// Do not change or translate the first text unless you know what you are doing\n// Assigning feature numbers is optional. Without it, it will automatically count for you, starting from 0\n// Assigned feature numbers can be like any numbers 1,3,200,10... instead in order 0,1,2,3,4,5...\n// ButtonLink, Category, RichTextView and RichWebView is not counted. They can't have feature number assigned\n// Toggle, ButtonOnOff and Checkbox can be switched on by default, if you add True_. Example: CheckBox_True_The Check Box\n// To learn HTML, go to this page: https://www.w3schools.com/\n\nJNIEXPORT jobjectArray\nJNICALL\nJava_uk_lgl_modmenu_FloatingModMenuService_getFeatureList(JNIEnv *env, jobject context) {\n    jobjectArray ret;\n\n    //Toasts added here so it's harder to remove it\n    MakeToast(env, context, OBFUSCATE(\"Modded by LGL\"), Toast::LENGTH_LONG);\n\n    const char *features[] = {\n            OBFUSCATE(\"Category_The Category\"), //Not counted\n            OBFUSCATE(\"Toggle_The toggle\"),\n            OBFUSCATE(\n                    \"100_Toggle_True_The toggle 2\"), //This one have feature number assigned, and switched on by default\n            OBFUSCATE(\"110_Toggle_The toggle 3\"), //This one too\n            OBFUSCATE(\"SeekBar_The slider_1_100\"),\n            OBFUSCATE(\"SeekBar_Kittymemory slider example_1_5\"),\n            OBFUSCATE(\"Spinner_The spinner_Items 1,Items 2,Items 3\"),\n            OBFUSCATE(\"Button_The button\"),\n            OBFUSCATE(\"ButtonLink_The button with link_https://www.youtube.com/\"), //Not counted\n            OBFUSCATE(\"ButtonOnOff_The On/Off button\"),\n            OBFUSCATE(\"CheckBox_The Check Box\"),\n            OBFUSCATE(\"InputValue_Input number\"),\n            OBFUSCATE(\"InputValue_1000_Input number 2\"), //Max value\n            OBFUSCATE(\"InputText_Input text\"),\n            OBFUSCATE(\"RadioButton_Radio buttons_OFF,Mod 1,Mod 2,Mod 3\"),\n\n            //Create new collapse\n            OBFUSCATE(\"Collapse_Collapse 1\"),\n            OBFUSCATE(\"CollapseAdd_Toggle_The toggle\"),\n            OBFUSCATE(\"CollapseAdd_Toggle_The toggle\"),\n            OBFUSCATE(\"123_CollapseAdd_Toggle_The toggle\"),\n            OBFUSCATE(\"CollapseAdd_Button_The button\"),\n\n            //Create new collapse again\n            OBFUSCATE(\"Collapse_Collapse 2\"),\n            OBFUSCATE(\"CollapseAdd_SeekBar_The slider_1_100\"),\n            OBFUSCATE(\"CollapseAdd_InputValue_Input number\"),\n\n            OBFUSCATE(\"RichTextView_This is text view, not fully HTML.\"\n                      \"<b>Bold</b> <i>italic</i> <u>underline</u>\"\n                      \"<br />New line <font color='red'>Support colors</font>\"\n                      \"<br/><big>bigger Text</big>\"),\n            OBFUSCATE(\"RichWebView_<html><head><style>body{color: white;}</style></head><body>\"\n                      \"This is WebView, with REAL HTML support!\"\n                      \"<div style=\\\"background-color: darkblue; text-align: center;\\\">Support CSS</div>\"\n                      \"<marquee style=\\\"color: green; font-weight:bold;\\\" direction=\\\"left\\\" scrollamount=\\\"5\\\" behavior=\\\"scroll\\\">This is <u>scrollable</u> text</marquee>\"\n                      \"</body></html>\")\n    };\n\n    //Now you dont have to manually update the number everytime;\n    int Total_Feature = (sizeof features / sizeof features[0]);\n    ret = (jobjectArray)\n            env->NewObjectArray(Total_Feature, env->FindClass(OBFUSCATE(\"java/lang/String\")),\n                                env->NewStringUTF(\"\"));\n\n    for (int i = 0; i < Total_Feature; i++)\n        env->SetObjectArrayElement(ret, i, env->NewStringUTF(features[i]));\n\n    pthread_t ptid;\n    pthread_create(&ptid, NULL, antiLeech, NULL);\n\n    return (ret);\n}\n\nJNIEXPORT void JNICALL\nJava_uk_lgl_modmenu_Preferences_Changes(JNIEnv *env, jclass clazz, jobject obj,\n                                        jint featNum, jstring featName, jint value,\n                                        jboolean boolean, jstring str) {\n\n    LOGD(OBFUSCATE(\"Feature name: %d - %s | Value: = %d | Bool: = %d | Text: = %s\"), featNum,\n         env->GetStringUTFChars(featName, 0), value,\n         boolean, str != NULL ? env->GetStringUTFChars(str, 0) : \"\");\n\n    //BE CAREFUL NOT TO ACCIDENTLY REMOVE break;\n\n    switch (featNum) {\n        case 0:\n            feature2 = boolean;\n            if (feature2) {\n                // To print bytes you can do this\n                //if (hexPatches.GodMode.Modify()) {\n                //    LOGD(OBFUSCATE(\"Current Bytes: %s\"),\n                //         hexPatches.GodMode.get_CurrBytes().c_str());\n                //}\n                hexPatches.GodMode.Modify();\n                hexPatches.GodMode2.Modify();\n                //LOGI(OBFUSCATE(\"On\"));\n            } else {\n                hexPatches.GodMode.Restore();\n                hexPatches.GodMode2.Restore();\n                //LOGI(OBFUSCATE(\"Off\"));\n            }\n            break;\n        case 100:\n            break;\n        case 110:\n            break;\n        case 1:\n            if (value >= 1) {\n                sliderValue = value;\n            }\n            break;\n        case 2:\n            switch (value) {\n                //For noobies\n                case 0:\n                    hexPatches.SliderExample = MemoryPatch::createWithHex(\n                            targetLibName, string2Offset(\n                                    OBFUSCATE(\"0x100000\")),\n                            OBFUSCATE(\n                                    \"00 00 A0 E3 1E FF 2F E1\"));\n                    hexPatches.SliderExample.Modify();\n                    break;\n                case 1:\n                    hexPatches.SliderExample = MemoryPatch::createWithHex(\n                            targetLibName, string2Offset(\n                                    OBFUSCATE(\"0x100000\")),\n                            OBFUSCATE(\n                                    \"01 00 A0 E3 1E FF 2F E1\"));\n                    hexPatches.SliderExample.Modify();\n                    break;\n                case 2:\n                    hexPatches.SliderExample = MemoryPatch::createWithHex(\n                            targetLibName,\n                            string2Offset(\n                                    OBFUSCATE(\"0x100000\")),\n                            OBFUSCATE(\n                                    \"02 00 A0 E3 1E FF 2F E1\"));\n                    hexPatches.SliderExample.Modify();\n                    break;\n            }\n            break;\n        case 3:\n            switch (value) {\n                case 0:\n                    LOGD(OBFUSCATE(\"Selected item 1\"));\n                    break;\n                case 1:\n                    LOGD(OBFUSCATE(\"Selected item 2\"));\n                    break;\n                case 2:\n                    LOGD(OBFUSCATE(\"Selected item 3\"));\n                    break;\n            }\n            break;\n        case 4:\n            // Since we have instanceBtn as a field, we can call it out of Update hook function\n            if (instanceBtn != NULL)\n                AddMoneyExample(instanceBtn, 999999);\n            // MakeToast(env, obj, OBFUSCATE(\"Button pressed\"), Toast::LENGTH_SHORT);\n            break;\n        case 5:\n            break;\n        case 6:\n            featureHookToggle = boolean;\n            break;\n        case 7:\n            level = value;\n            break;\n        case 8:\n            //MakeToast(env, obj, TextInput, Toast::LENGTH_SHORT);\n            break;\n        case 9:\n            break;\n    }\n}\n}\n\n//No need to use JNI_OnLoad, since we don't use JNIEnv\n//We do this to hide OnLoad from disassembler\n__attribute__((constructor))\nvoid lib_main() {\n    // Create a new thread so it does not block the main thread, means the game would not freeze\n    pthread_t ptid;\n    pthread_create(&ptid, NULL, hack_thread, NULL);\n}\n\n/*\nJNIEXPORT jint JNICALL\nJNI_OnLoad(JavaVM *vm, void *reserved) {\n    JNIEnv *globalEnv;\n    vm->GetEnv((void **) &globalEnv, JNI_VERSION_1_6);\n    return JNI_VERSION_1_6;\n}\n */\n","size_bytes":13940},"app/src/main/jni/And64InlineHook/And64InlineHook.cpp":{"content":"/*\n *  @date   : 2018/04/18\n *  @author : Rprop (r_prop@outlook.com)\n *  https://github.com/Rprop/And64InlineHook\n */\n/*\n MIT License\n\n Copyright (c) 2018 Rprop (r_prop@outlook.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n */\n#define  __STDC_FORMAT_MACROS\n\n#include <inttypes.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <android/log.h>\n#include <cstring>\n#include <errno.h>\n\n#if defined(__aarch64__)\n\n#include \"And64InlineHook.hpp\"\n\n#define   A64_MAX_INSTRUCTIONS 5\n#define   A64_MAX_REFERENCES   (A64_MAX_INSTRUCTIONS * 2)\n#define   A64_NOP              0xd503201fu\n#define   A64_JNIEXPORT        __attribute__((visibility(\"hidden\")))\n#define   A64_LOGE(...)        ((void)__android_log_print(ANDROID_LOG_ERROR, \"A64_HOOK\", __VA_ARGS__))\n#ifndef NDEBUG\n# define  A64_LOGI(...)        ((void)__android_log_print(ANDROID_LOG_INFO, \"A64_HOOK\", __VA_ARGS__))\n#else\n# define  A64_LOGI(...)        ((void)0)\n#endif // NDEBUG\ntypedef uint32_t *__restrict *__restrict instruction;\ntypedef struct {\n    struct fix_info {\n        uint32_t *bp;\n        uint32_t ls; // left-shift counts\n        uint32_t ad; // & operand\n    };\n    struct insns_info {\n        union {\n            uint64_t insu;\n            int64_t ins;\n            void *insp;\n        };\n        fix_info fmap[A64_MAX_REFERENCES];\n    };\n    int64_t basep;\n    int64_t endp;\n    insns_info dat[A64_MAX_INSTRUCTIONS];\n\npublic:\n    inline bool is_in_fixing_range(const int64_t absolute_addr) {\n        return absolute_addr >= this->basep && absolute_addr < this->endp;\n    }\n\n    inline intptr_t get_ref_ins_index(const int64_t absolute_addr) {\n        return static_cast<intptr_t>((absolute_addr - this->basep) / sizeof(uint32_t));\n    }\n\n    inline intptr_t get_and_set_current_index(uint32_t *__restrict inp, uint32_t *__restrict outp) {\n        intptr_t current_idx = this->get_ref_ins_index(reinterpret_cast<int64_t>(inp));\n        this->dat[current_idx].insp = outp;\n        return current_idx;\n    }\n\n    inline void reset_current_ins(const intptr_t idx, uint32_t *__restrict outp) {\n        this->dat[idx].insp = outp;\n    }\n\n    void\n    insert_fix_map(const intptr_t idx, uint32_t *bp, uint32_t ls = 0u, uint32_t ad = 0xffffffffu) {\n        for (auto &f : this->dat[idx].fmap) {\n            if (f.bp == NULL) {\n                f.bp = bp;\n                f.ls = ls;\n                f.ad = ad;\n                return;\n            } //if\n        }\n        // What? GGing..\n    }\n\n    void process_fix_map(const intptr_t idx) {\n        for (auto &f : this->dat[idx].fmap) {\n            if (f.bp == NULL) break;\n            *(f.bp) = *(f.bp) |\n                      (((int32_t(this->dat[idx].ins - reinterpret_cast<int64_t>(f.bp)) >> 2)\n                              << f.ls) & f.ad);\n            f.bp = NULL;\n        }\n    }\n} context;\n\n//-------------------------------------------------------------------------\n\nstatic bool __fix_branch_imm(instruction inpp, instruction outpp, context *ctxp) {\n    static constexpr uint32_t mbits = 6u;\n    static constexpr uint32_t mask = 0xfc000000u; // 0b11111100000000000000000000000000\n    static constexpr uint32_t rmask = 0x03ffffffu; // 0b00000011111111111111111111111111\n    static constexpr uint32_t op_b = 0x14000000u; // \"b\"  ADDR_PCREL26\n    static constexpr uint32_t op_bl = 0x94000000u; // \"bl\" ADDR_PCREL26\n\n    const uint32_t ins = *(*inpp);\n    const uint32_t opc = ins & mask;\n    switch (opc) {\n        case op_b:\n        case op_bl: {\n            intptr_t current_idx = ctxp->get_and_set_current_index(*inpp, *outpp);\n            int64_t absolute_addr = reinterpret_cast<int64_t>(*inpp) +\n                                    (static_cast<int32_t>(ins << mbits)\n                                            >> (mbits - 2u)); // sign-extended\n            int64_t new_pc_offset =\n                    static_cast<int64_t>(absolute_addr - reinterpret_cast<int64_t>(*outpp))\n                            >> 2; // shifted\n            bool special_fix_type = ctxp->is_in_fixing_range(absolute_addr);\n            // whether the branch should be converted to absolute jump\n            if (!special_fix_type && llabs(new_pc_offset) >= (rmask >> 1)) {\n                bool b_aligned = (reinterpret_cast<uint64_t>(*outpp + 2) & 7u) == 0u;\n                if (opc == op_b) {\n                    if (b_aligned != true) {\n                        (*outpp)[0] = A64_NOP;\n                        ctxp->reset_current_ins(current_idx, ++(*outpp));\n                    } //if\n                    (*outpp)[0] = 0x58000051u; // LDR X17, #0x8\n                    (*outpp)[1] = 0xd61f0220u; // BR X17\n                    memcpy(*outpp + 2, &absolute_addr, sizeof(absolute_addr));\n                    *outpp += 4;\n                } else {\n                    if (b_aligned == true) {\n                        (*outpp)[0] = A64_NOP;\n                        ctxp->reset_current_ins(current_idx, ++(*outpp));\n                    } //if\n                    (*outpp)[0] = 0x58000071u; // LDR X17, #12\n                    (*outpp)[1] = 0x1000009eu; // ADR X30, #16\n                    (*outpp)[2] = 0xd61f0220u; // BR X17\n                    memcpy(*outpp + 3, &absolute_addr, sizeof(absolute_addr));\n                    *outpp += 5;\n                } //if\n            } else {\n                if (special_fix_type) {\n                    intptr_t ref_idx = ctxp->get_ref_ins_index(absolute_addr);\n                    if (ref_idx <= current_idx) {\n                        new_pc_offset = static_cast<int64_t>(ctxp->dat[ref_idx].ins -\n                                                             reinterpret_cast<int64_t>(*outpp))\n                                >> 2;\n                    } else {\n                        ctxp->insert_fix_map(ref_idx, *outpp, 0u, rmask);\n                        new_pc_offset = 0;\n                    } //if\n                } //if\n\n                (*outpp)[0] = opc | (new_pc_offset & ~mask);\n                ++(*outpp);\n            } //if\n\n            ++(*inpp);\n            return ctxp->process_fix_map(current_idx), true;\n        }\n    }\n    return false;\n}\n\n//-------------------------------------------------------------------------\n\nstatic bool __fix_cond_comp_test_branch(instruction inpp, instruction outpp, context *ctxp) {\n    static constexpr uint32_t lsb = 5u;\n    static constexpr uint32_t lmask01 = 0xff00001fu; // 0b11111111000000000000000000011111\n    static constexpr uint32_t mask0 = 0xff000010u; // 0b11111111000000000000000000010000\n    static constexpr uint32_t op_bc = 0x54000000u; // \"b.c\"  ADDR_PCREL19\n    static constexpr uint32_t mask1 = 0x7f000000u; // 0b01111111000000000000000000000000\n    static constexpr uint32_t op_cbz = 0x34000000u; // \"cbz\"  Rt, ADDR_PCREL19\n    static constexpr uint32_t op_cbnz = 0x35000000u; // \"cbnz\" Rt, ADDR_PCREL19\n    static constexpr uint32_t lmask2 = 0xfff8001fu; // 0b11111111111110000000000000011111\n    static constexpr uint32_t mask2 = 0x7f000000u; // 0b01111111000000000000000000000000\n    static constexpr uint32_t op_tbz = 0x36000000u; // 0b00110110000000000000000000000000 \"tbz\"  Rt, BIT_NUM, ADDR_PCREL14\n    static constexpr uint32_t op_tbnz = 0x37000000u; // 0b00110111000000000000000000000000 \"tbnz\" Rt, BIT_NUM, ADDR_PCREL14\n\n    const uint32_t ins = *(*inpp);\n    uint32_t lmask = lmask01;\n    if ((ins & mask0) != op_bc) {\n        uint32_t opc = ins & mask1;\n        if (opc != op_cbz && opc != op_cbnz) {\n            opc = ins & mask2;\n            if (opc != op_tbz && opc != op_tbnz) {\n                return false;\n            } //if\n            lmask = lmask2;\n        } //if\n    } //if\n\n    intptr_t current_idx = ctxp->get_and_set_current_index(*inpp, *outpp);\n    int64_t absolute_addr = reinterpret_cast<int64_t>(*inpp) + ((ins & ~lmask) >> (lsb - 2u));\n    int64_t new_pc_offset =\n            static_cast<int64_t>(absolute_addr - reinterpret_cast<int64_t>(*outpp)) >> 2; // shifted\n    bool special_fix_type = ctxp->is_in_fixing_range(absolute_addr);\n    if (!special_fix_type && llabs(new_pc_offset) >= (~lmask >> (lsb + 1))) {\n        if ((reinterpret_cast<uint64_t>(*outpp + 4) & 7u) != 0u) {\n            (*outpp)[0] = A64_NOP;\n            ctxp->reset_current_ins(current_idx, ++(*outpp));\n        } //if\n        (*outpp)[0] = (((8u >> 2u) << lsb) & ~lmask) | (ins & lmask); // B.C #0x8\n        (*outpp)[1] = 0x14000005u; // B #0x14\n        (*outpp)[2] = 0x58000051u; // LDR X17, #0x8\n        (*outpp)[3] = 0xd61f0220u; // BR X17\n        memcpy(*outpp + 4, &absolute_addr, sizeof(absolute_addr));\n        *outpp += 6;\n    } else {\n        if (special_fix_type) {\n            intptr_t ref_idx = ctxp->get_ref_ins_index(absolute_addr);\n            if (ref_idx <= current_idx) {\n                new_pc_offset = static_cast<int64_t>(ctxp->dat[ref_idx].ins -\n                                                     reinterpret_cast<int64_t>(*outpp)) >> 2;\n            } else {\n                ctxp->insert_fix_map(ref_idx, *outpp, lsb, ~lmask);\n                new_pc_offset = 0;\n            } //if\n        } //if\n\n        (*outpp)[0] = (static_cast<uint32_t>(new_pc_offset << lsb) & ~lmask) | (ins & lmask);\n        ++(*outpp);\n    } //if\n\n    ++(*inpp);\n    return ctxp->process_fix_map(current_idx), true;\n}\n\n//-------------------------------------------------------------------------\n\nstatic bool __fix_loadlit(instruction inpp, instruction outpp, context *ctxp) {\n    const uint32_t ins = *(*inpp);\n\n    // memory prefetch(\"prfm\"), just skip it\n    // http://infocenter.arm.com/help/topic/com.arm.doc.100069_0608_00_en/pge1427897420050.html\n    if ((ins & 0xff000000u) == 0xd8000000u) {\n        ctxp->process_fix_map(ctxp->get_and_set_current_index(*inpp, *outpp));\n        ++(*inpp);\n        return true;\n    } //if\n\n    static constexpr uint32_t msb = 8u;\n    static constexpr uint32_t lsb = 5u;\n    static constexpr uint32_t mask_30 = 0x40000000u; // 0b01000000000000000000000000000000\n    static constexpr uint32_t mask_31 = 0x80000000u; // 0b10000000000000000000000000000000\n    static constexpr uint32_t lmask = 0xff00001fu; // 0b11111111000000000000000000011111\n    static constexpr uint32_t mask_ldr = 0xbf000000u; // 0b10111111000000000000000000000000\n    static constexpr uint32_t op_ldr = 0x18000000u; // 0b00011000000000000000000000000000 \"LDR Wt/Xt, label\" | ADDR_PCREL19\n    static constexpr uint32_t mask_ldrv = 0x3f000000u; // 0b00111111000000000000000000000000\n    static constexpr uint32_t op_ldrv = 0x1c000000u; // 0b00011100000000000000000000000000 \"LDR St/Dt/Qt, label\" | ADDR_PCREL19\n    static constexpr uint32_t mask_ldrsw = 0xff000000u; // 0b11111111000000000000000000000000\n    static constexpr uint32_t op_ldrsw = 0x98000000u; // \"LDRSW Xt, label\" | ADDR_PCREL19 | load register signed word\n    // LDR S0, #0 | 0b00011100000000000000000000000000 | 32-bit\n    // LDR D0, #0 | 0b01011100000000000000000000000000 | 64-bit\n    // LDR Q0, #0 | 0b10011100000000000000000000000000 | 128-bit\n    // INVALID    | 0b11011100000000000000000000000000 | may be 256-bit\n\n    uint32_t mask = mask_ldr;\n    uintptr_t faligned = (ins & mask_30) ? 7u : 3u;\n    if ((ins & mask_ldr) != op_ldr) {\n        mask = mask_ldrv;\n        if (faligned != 7u)\n            faligned = (ins & mask_31) ? 15u : 3u;\n        if ((ins & mask_ldrv) != op_ldrv) {\n            if ((ins & mask_ldrsw) != op_ldrsw) {\n                return false;\n            } //if\n            mask = mask_ldrsw;\n            faligned = 7u;\n        } //if\n    } //if\n\n    intptr_t current_idx = ctxp->get_and_set_current_index(*inpp, *outpp);\n    int64_t absolute_addr = reinterpret_cast<int64_t>(*inpp) +\n                            ((static_cast<int32_t>(ins << msb) >> (msb + lsb - 2u)) & ~3u);\n    int64_t new_pc_offset =\n            static_cast<int64_t>(absolute_addr - reinterpret_cast<int64_t>(*outpp)) >> 2; // shifted\n    bool special_fix_type = ctxp->is_in_fixing_range(absolute_addr);\n    // special_fix_type may encounter issue when there are mixed data and code\n    if (special_fix_type || (llabs(new_pc_offset) + (faligned + 1u - 4u) / 4u) >=\n                            (~lmask >> (lsb + 1))) { // inaccurate, but it works\n        while ((reinterpret_cast<uint64_t>(*outpp + 2) & faligned) != 0u) {\n            *(*outpp)++ = A64_NOP;\n        }\n        ctxp->reset_current_ins(current_idx, *outpp);\n\n        // Note that if memory at absolute_addr is writeable (non-const), we will fail to fetch it.\n        // And what's worse, we may unexpectedly overwrite something if special_fix_type is true...\n        uint32_t ns = static_cast<uint32_t>((faligned + 1) / sizeof(uint32_t));\n        (*outpp)[0] = (((8u >> 2u) << lsb) & ~mask) | (ins & lmask); // LDR #0x8\n        (*outpp)[1] = 0x14000001u + ns; // B #0xc\n        memcpy(*outpp + 2, reinterpret_cast<void *>(absolute_addr), faligned + 1);\n        *outpp += 2 + ns;\n    } else {\n        faligned >>= 2; // new_pc_offset is shifted and 4-byte aligned\n        while ((new_pc_offset & faligned) != 0) {\n            *(*outpp)++ = A64_NOP;\n            new_pc_offset =\n                    static_cast<int64_t>(absolute_addr - reinterpret_cast<int64_t>(*outpp)) >> 2;\n        }\n        ctxp->reset_current_ins(current_idx, *outpp);\n\n        (*outpp)[0] = (static_cast<uint32_t>(new_pc_offset << lsb) & ~mask) | (ins & lmask);\n        ++(*outpp);\n    } //if\n\n    ++(*inpp);\n    return ctxp->process_fix_map(current_idx), true;\n}\n\n//-------------------------------------------------------------------------\n\nstatic bool __fix_pcreladdr(instruction inpp, instruction outpp, context *ctxp) {\n    // Load a PC-relative address into a register\n    // http://infocenter.arm.com/help/topic/com.arm.doc.100069_0608_00_en/pge1427897645644.html\n    static constexpr uint32_t msb = 8u;\n    static constexpr uint32_t lsb = 5u;\n    static constexpr uint32_t mask = 0x9f000000u; // 0b10011111000000000000000000000000\n    static constexpr uint32_t rmask = 0x0000001fu; // 0b00000000000000000000000000011111\n    static constexpr uint32_t lmask = 0xff00001fu; // 0b11111111000000000000000000011111\n    static constexpr uint32_t fmask = 0x00ffffffu; // 0b00000000111111111111111111111111\n    static constexpr uint32_t max_val = 0x001fffffu; // 0b00000000000111111111111111111111\n    static constexpr uint32_t op_adr = 0x10000000u; // \"adr\"  Rd, ADDR_PCREL21\n    static constexpr uint32_t op_adrp = 0x90000000u; // \"adrp\" Rd, ADDR_ADRP\n\n    const uint32_t ins = *(*inpp);\n    intptr_t current_idx;\n    switch (ins & mask) {\n        case op_adr: {\n            current_idx = ctxp->get_and_set_current_index(*inpp, *outpp);\n            int64_t lsb_bytes = static_cast<uint32_t>(ins << 1u) >> 30u;\n            int64_t absolute_addr = reinterpret_cast<int64_t>(*inpp) +\n                                    (((static_cast<int32_t>(ins << msb) >> (msb + lsb - 2u)) &\n                                      ~3u) | lsb_bytes);\n            int64_t new_pc_offset = static_cast<int64_t>(absolute_addr -\n                                                         reinterpret_cast<int64_t>(*outpp));\n            bool special_fix_type = ctxp->is_in_fixing_range(absolute_addr);\n            if (!special_fix_type && llabs(new_pc_offset) >= (max_val >> 1)) {\n                if ((reinterpret_cast<uint64_t>(*outpp + 2) & 7u) != 0u) {\n                    (*outpp)[0] = A64_NOP;\n                    ctxp->reset_current_ins(current_idx, ++(*outpp));\n                } //if\n\n                (*outpp)[0] =\n                        0x58000000u | (((8u >> 2u) << lsb) & ~mask) | (ins & rmask); // LDR #0x8\n                (*outpp)[1] = 0x14000003u; // B #0xc\n                memcpy(*outpp + 2, &absolute_addr, sizeof(absolute_addr));\n                *outpp += 4;\n            } else {\n                if (special_fix_type) {\n                    intptr_t ref_idx = ctxp->get_ref_ins_index(absolute_addr & ~3ull);\n                    if (ref_idx <= current_idx) {\n                        new_pc_offset = static_cast<int64_t>(ctxp->dat[ref_idx].ins -\n                                                             reinterpret_cast<int64_t>(*outpp));\n                    } else {\n                        ctxp->insert_fix_map(ref_idx, *outpp, lsb, fmask);\n                        new_pc_offset = 0;\n                    } //if\n                } //if\n\n                // the lsb_bytes will never be changed, so we can use lmask to keep it\n                (*outpp)[0] = (static_cast<uint32_t>(new_pc_offset << (lsb - 2u)) & fmask) |\n                              (ins & lmask);\n                ++(*outpp);\n            } //if\n        }\n            break;\n        case op_adrp: {\n            current_idx = ctxp->get_and_set_current_index(*inpp, *outpp);\n            int32_t lsb_bytes = static_cast<uint32_t>(ins << 1u) >> 30u;\n            int64_t absolute_addr = (reinterpret_cast<int64_t>(*inpp) & ~0xfffll) +\n                                    ((((static_cast<int32_t>(ins << msb) >> (msb + lsb - 2u)) &\n                                       ~3u) | lsb_bytes) << 12);\n            A64_LOGI(\"ins = 0x%.8X, pc = %p, abs_addr = %p\",\n                     ins, *inpp, reinterpret_cast<int64_t *>(absolute_addr));\n            if (ctxp->is_in_fixing_range(absolute_addr)) {\n                intptr_t ref_idx = ctxp->get_ref_ins_index(absolute_addr/* & ~3ull*/);\n                if (ref_idx > current_idx) {\n                    // the bottom 12 bits of absolute_addr are masked out,\n                    // so ref_idx must be less than or equal to current_idx!\n                    A64_LOGE(\"ref_idx must be less than or equal to current_idx!\");\n                } //if\n\n                // *absolute_addr may be changed due to relocation fixing\n                A64_LOGI(\"What is the correct way to fix this?\");\n                *(*outpp)++ = ins; // 0x90000000u;\n            } else {\n                if ((reinterpret_cast<uint64_t>(*outpp + 2) & 7u) != 0u) {\n                    (*outpp)[0] = A64_NOP;\n                    ctxp->reset_current_ins(current_idx, ++(*outpp));\n                } //if\n\n                (*outpp)[0] =\n                        0x58000000u | (((8u >> 2u) << lsb) & ~mask) | (ins & rmask); // LDR #0x8\n                (*outpp)[1] = 0x14000003u; // B #0xc\n                memcpy(*outpp + 2, &absolute_addr, sizeof(absolute_addr)); // potential overflow?\n                *outpp += 4;\n            } //if\n        }\n            break;\n        default:\n            return false;\n    }\n\n    ctxp->process_fix_map(current_idx);\n    ++(*inpp);\n    return true;\n}\n\n//-------------------------------------------------------------------------\n#define __flush_cache(c, n)        __builtin___clear_cache(reinterpret_cast<char *>(c), reinterpret_cast<char *>(c) + n)\n\nstatic void __fix_instructions(uint32_t *__restrict inp, int32_t count, uint32_t *__restrict outp) {\n    context ctx;\n    ctx.basep = reinterpret_cast<int64_t>(inp);\n    ctx.endp = reinterpret_cast<int64_t>(inp + count);\n    memset(ctx.dat, 0, sizeof(ctx.dat));\n    static_assert(sizeof(ctx.dat) / sizeof(ctx.dat[0]) == A64_MAX_INSTRUCTIONS,\n                  \"please use A64_MAX_INSTRUCTIONS!\");\n#ifndef NDEBUG\n    if (count > A64_MAX_INSTRUCTIONS) {\n        A64_LOGE(\"too many fixing instructions!\");\n    } //if\n#endif // NDEBUG\n\n    uint32_t *const outp_base = outp;\n\n    while (--count >= 0) {\n        if (__fix_branch_imm(&inp, &outp, &ctx)) continue;\n        if (__fix_cond_comp_test_branch(&inp, &outp, &ctx)) continue;\n        if (__fix_loadlit(&inp, &outp, &ctx)) continue;\n        if (__fix_pcreladdr(&inp, &outp, &ctx)) continue;\n\n        // without PC-relative offset\n        ctx.process_fix_map(ctx.get_and_set_current_index(inp, outp));\n        *(outp++) = *(inp++);\n    }\n\n    static constexpr uint_fast64_t mask = 0x03ffffffu; // 0b00000011111111111111111111111111\n    auto callback = reinterpret_cast<int64_t>(inp);\n    auto pc_offset = static_cast<int64_t>(callback - reinterpret_cast<int64_t>(outp)) >> 2;\n    if (llabs(pc_offset) >= (mask >> 1)) {\n        if ((reinterpret_cast<uint64_t>(outp + 2) & 7u) != 0u) {\n            outp[0] = A64_NOP;\n            ++outp;\n        } //if\n        outp[0] = 0x58000051u; // LDR X17, #0x8\n        outp[1] = 0xd61f0220u; // BR X17\n        *reinterpret_cast<int64_t *>(outp + 2) = callback;\n        outp += 4;\n    } else {\n        outp[0] = 0x14000000u | (pc_offset & mask); // \"B\" ADDR_PCREL26\n        ++outp;\n    } //if\n\n    const uintptr_t total = (outp - outp_base) * sizeof(uint32_t);\n    __flush_cache(outp_base, total); // necessary\n}\n\n//-------------------------------------------------------------------------\n\nextern \"C\" {\n#define __attribute                __attribute__\n#define aligned(x)                 __aligned__(x)\n#define __intval(p)                reinterpret_cast<intptr_t>(p)\n#define __uintval(p)               reinterpret_cast<uintptr_t>(p)\n#define __ptr(p)                   reinterpret_cast<void *>(p)\n#define __page_size                4096\n#define __page_align(n)            __align_up(static_cast<uintptr_t>(n), __page_size)\n#define __ptr_align(x)             __ptr(__align_down(reinterpret_cast<uintptr_t>(x), __page_size))\n#define __align_up(x, n)           (((x) + ((n) - 1)) & ~((n) - 1))\n#define __align_down(x, n)         ((x) & -(n))\n#define __countof(x)               static_cast<intptr_t>(sizeof(x) / sizeof((x)[0])) // must be signed\n#define __atomic_increase(p)       __sync_add_and_fetch(p, 1)\n#define __sync_cmpswap(p, v, n)    __sync_bool_compare_and_swap(p, v, n)\n#define __predict_true(exp)        __builtin_expect((exp) != 0, 1)\n#define __make_rwx(p, n)           ::mprotect(__ptr_align(p), \\\n                                              __page_align(__uintval(p) + n) != __page_align(__uintval(p)) ? __page_align(n) + __page_size : __page_align(n), \\\n                                              PROT_READ | PROT_WRITE | PROT_EXEC)\n\n//-------------------------------------------------------------------------\n\nstatic __attribute((aligned(__page_size))) uint32_t __insns_pool[A64_MAX_BACKUPS][\n        A64_MAX_INSTRUCTIONS * 10];\n\n//-------------------------------------------------------------------------\n\nclass A64HookInit {\npublic:\n    A64HookInit() {\n        __make_rwx(__insns_pool, sizeof(__insns_pool));\n        A64_LOGI(\"insns pool initialized.\");\n    }\n};\nstatic A64HookInit __init;\n\n//-------------------------------------------------------------------------\n\nstatic uint32_t *FastAllocateTrampoline() {\n    static_assert((A64_MAX_INSTRUCTIONS * 10 * sizeof(uint32_t)) % 8 == 0, \"8-byte align\");\n    static volatile int32_t __index = -1;\n\n    int32_t i = __atomic_increase(&__index);\n    if (__predict_true(i >= 0 && i < __countof(__insns_pool))) {\n        return __insns_pool[i];\n    } //if\n\n    A64_LOGE(\"failed to allocate trampoline!\");\n    return NULL;\n}\n\n//-------------------------------------------------------------------------\n\nA64_JNIEXPORT void *A64HookFunctionV(void *const symbol, void *const replace,\n                                     void *const rwx, const uintptr_t rwx_size) {\n    static constexpr uint_fast64_t mask = 0x03ffffffu; // 0b00000011111111111111111111111111\n\n    uint32_t *trampoline = static_cast<uint32_t *>(rwx), *original = static_cast<uint32_t *>(symbol);\n\n    static_assert(A64_MAX_INSTRUCTIONS >= 5, \"please fix A64_MAX_INSTRUCTIONS!\");\n    auto pc_offset = static_cast<int64_t>(__intval(replace) - __intval(symbol)) >> 2;\n    if (llabs(pc_offset) >= (mask >> 1)) {\n        int32_t count = (reinterpret_cast<uint64_t>(original + 2) & 7u) != 0u ? 5 : 4;\n        if (trampoline) {\n            if (rwx_size < count * 10u) {\n                A64_LOGI(\"rwx size is too small to hold %u bytes backup instructions!\",\n                         count * 10u);\n                return NULL;\n            } //if\n            __fix_instructions(original, count, trampoline);\n        } //if\n\n        if (__make_rwx(original, 5 * sizeof(uint32_t)) == 0) {\n            if (count == 5) {\n                original[0] = A64_NOP;\n                ++original;\n            } //if\n            original[0] = 0x58000051u; // LDR X17, #0x8\n            original[1] = 0xd61f0220u; // BR X17\n            *reinterpret_cast<int64_t *>(original + 2) = __intval(replace);\n            __flush_cache(symbol, 5 * sizeof(uint32_t));\n\n            A64_LOGI(\"inline hook %p->%p successfully! %zu bytes overwritten\",\n                     symbol, replace, 5 * sizeof(uint32_t));\n        } else {\n            A64_LOGE(\"mprotect failed with errno = %d, p = %p, size = %zu\",\n                     errno, original, 5 * sizeof(uint32_t));\n            trampoline = NULL;\n        } //if\n    } else {\n        if (trampoline) {\n            if (rwx_size < 1u * 10u) {\n                A64_LOGI(\"rwx size is too small to hold %u bytes backup instructions!\", 1u * 10u);\n                return NULL;\n            } //if\n            __fix_instructions(original, 1, trampoline);\n        } //if\n\n        if (__make_rwx(original, 1 * sizeof(uint32_t)) == 0) {\n            __sync_cmpswap(original, *original,\n                           0x14000000u | (pc_offset & mask)); // \"B\" ADDR_PCREL26\n            __flush_cache(symbol, 1 * sizeof(uint32_t));\n\n            A64_LOGI(\"inline hook %p->%p successfully! %zu bytes overwritten\",\n                     symbol, replace, 1 * sizeof(uint32_t));\n        } else {\n            A64_LOGE(\"mprotect failed with errno = %d, p = %p, size = %zu\",\n                     errno, original, 1 * sizeof(uint32_t));\n            trampoline = NULL;\n        } //if\n    } //if\n\n    return trampoline;\n}\n\n//-------------------------------------------------------------------------\n\nA64_JNIEXPORT void A64HookFunction(void *const symbol, void *const replace, void **result) {\n    void *trampoline = NULL;\n    if (result != NULL) {\n        trampoline = FastAllocateTrampoline();\n        *result = trampoline;\n        if (trampoline == NULL) return;\n    } //if\n\n    //fix Android 10 .text segment is read-only by default\n    __make_rwx(symbol, 5 * sizeof(size_t));\n\n    trampoline = A64HookFunctionV(symbol, replace, trampoline, A64_MAX_INSTRUCTIONS * 10u);\n    if (trampoline == NULL && result != NULL) {\n        *result = NULL;\n    } //if\n}\n}\n\n#endif // defined(__aarch64__)","size_bytes":27122},"app/src/main/jni/And64InlineHook/README.md":{"content":"# And64InlineHook\nLightweight ARMv8-A(ARM64, AArch64, Little-Endian) Inline Hook Library for Android C/C++   \n\n# References\n[Arm Compiler armasm User Guide](http://infocenter.arm.com/help/topic/com.arm.doc.100069_0610_00_en/pge1427898258836.html)   \n[Procedure Call Standard for the Arm® 64-bit Architecture (AArch64)](https://github.com/ARM-software/abi-aa/blob/master/aapcs64/aapcs64.rst)   \n\n","size_bytes":396},"app/src/main/jni/KittyMemory/KittyMemory.cpp":{"content":"//\n//  KittyMemory.cpp\n//\n//  Created by MJ (Ruit) on 1/1/19.\n//\n\n#include <Includes/obfuscate.h>\n#include \"KittyMemory.h\"\n\nusing KittyMemory::Memory_Status;\nusing KittyMemory::ProcMap;\n\n\nstruct mapsCache {\n    std::string identifier;\n    ProcMap map;\n};\n\nstatic std::vector<mapsCache> __mapsCache;\nstatic ProcMap findMapInCache(std::string id){\n    ProcMap ret;\n    for(int i = 0; i < __mapsCache.size(); i++){\n        if(__mapsCache[i].identifier.compare(id) == 0){\n            ret = __mapsCache[i].map;\n            break;\n        }\n    }\n    return ret;\n}\n\n\nbool KittyMemory::ProtectAddr(void *addr, size_t length, int protection) {\n   uintptr_t pageStart = _PAGE_START_OF_(addr);\n   uintptr_t pageLen   = _PAGE_LEN_OF_(addr, length);\n   return (\n     mprotect(reinterpret_cast<void *>(pageStart), pageLen, protection) != -1\n );\n}\n\n\nMemory_Status KittyMemory::memWrite(void *addr, const void *buffer, size_t len) {\n    if (addr == NULL)\n        return INV_ADDR;\n\n    if (buffer == NULL)\n        return INV_BUF;\n\n    if (len < 1 || len > INT_MAX)\n        return INV_LEN;\n\n    if (!ProtectAddr(addr, len, _PROT_RWX_))\n        return INV_PROT;\n\n    if (memcpy(addr, buffer, len) != NULL && ProtectAddr(addr, len, _PROT_RX_))\n        return SUCCESS;\n\n    return FAILED;\n}\n\n\nMemory_Status KittyMemory::memRead(void *buffer, const void *addr, size_t len) {\n    if (addr == NULL)\n        return INV_ADDR;\n\n    if (buffer == NULL)\n        return INV_BUF;\n\n    if (len < 1 || len > INT_MAX)\n        return INV_LEN;\n\n    if (memcpy(buffer, addr, len) != NULL)\n        return SUCCESS;\n\n    return FAILED;\n}\n\n\nstd::string KittyMemory::read2HexStr(const void *addr, size_t len) {\n    char temp[len];\n    memset(temp, 0, len);\n\n    const size_t bufferLen = len * 2 + 1;\n    char buffer[bufferLen];\n    memset(buffer, 0, bufferLen);\n\n    std::string ret;\n\n    if (memRead(temp, addr, len) != SUCCESS)\n        return ret;\n\n    for (int i = 0; i < len; i++) {\n        sprintf(&buffer[i * 2], \"%02X\", (unsigned char) temp[i]);\n    }\n\n    ret += buffer;\n    return ret;\n}\n\nProcMap KittyMemory::getLibraryMap(const char *libraryName) {\n    ProcMap retMap;\n    char line[512] = {0};\n\n    FILE *fp = fopen(OBFUSCATE(\"/proc/self/maps\"), OBFUSCATE(\"rt\"));\n    if (fp != NULL) {\n        while (fgets(line, sizeof(line), fp)) {\n            if (strstr(line, libraryName)) {\n                char tmpPerms[5] = {0}, tmpDev[12] = {0}, tmpPathname[444] = {0};\n                // parse a line in maps file\n                // (format) startAddress-endAddress perms offset dev inode pathname\n                sscanf(line, \"%llx-%llx %s %ld %s %d %s\",\n                       (long long unsigned *) &retMap.startAddr,\n                       (long long unsigned *) &retMap.endAddr,\n                       tmpPerms, &retMap.offset, tmpDev, &retMap.inode, tmpPathname);\n\n                retMap.length = (uintptr_t) retMap.endAddr - (uintptr_t) retMap.startAddr;\n                retMap.perms = tmpPerms;\n                retMap.dev = tmpDev;\n                retMap.pathname = tmpPathname;\n\n                break;\n            }\n        }\n        fclose(fp);\n    }\n    return retMap;\n}\n\nuintptr_t KittyMemory::getAbsoluteAddress(const char *libraryName, uintptr_t relativeAddr, bool useCache) {\n    ProcMap libMap;\n\n    if(useCache){\n        libMap = findMapInCache(libraryName);\n        if(libMap.isValid())\n        return (reinterpret_cast<uintptr_t>(libMap.startAddr) + relativeAddr);\n    }\n\n    libMap = getLibraryMap(libraryName);\n    if (!libMap.isValid())\n        return 0;\n\n    if(useCache){\n        mapsCache cachedMap;\n        cachedMap.identifier = libraryName;\n        cachedMap.map        = libMap;\n        __mapsCache.push_back(cachedMap);\n    }\n\n    return (reinterpret_cast<uintptr_t>(libMap.startAddr) + relativeAddr);\n}\n","size_bytes":3797},"app/src/main/jni/KittyMemory/KittyUtils.cpp":{"content":"#include \"KittyUtils.h\"\n\nstatic void xtrim(std::string &hex){\n    if(hex.compare(0, 2, \"0x\") == 0){\n        hex.erase(0, 2);\n    }\n\n    // https://www.techiedelight.com/remove-whitespaces-string-cpp/\n    hex.erase(std::remove_if(hex.begin(), hex.end(), [](char c){\n\t\t\t\t\t\t\t\treturn (c == ' ' || c == '\\n' || c == '\\r' ||\n\t\t\t\t\t\t\t\t\t\tc == '\\t' || c == '\\v' || c == '\\f');\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\thex.end());\n}\n\n\nbool KittyUtils::validateHexString(std::string &xstr){\n    if(xstr.length() < 2) return false;\n    xtrim(xstr); // first remove spaces\n    if(xstr.length() % 2 != 0) return false;\n    for(size_t i = 0; i < xstr.length(); i++){\n        if(!std::isxdigit((unsigned char)xstr[i])){\n            return false;\n        }\n    }\n    return true;\n}\n\n\n// https://tweex.net/post/c-anything-tofrom-a-hex-string/\n#include <sstream>\n#include <iomanip>\n\n\n// ------------------------------------------------------------------\n/*!\n    Convert a block of data to a hex string\n*/\nvoid KittyUtils::toHex(\n    void *const data,           //!< Data to convert\n    const size_t dataLength,    //!< Length of the data to convert\n    std::string &dest           //!< Destination string\n    )\n{\n    unsigned char     *byteData = reinterpret_cast<unsigned char*>(data);\n    std::stringstream hexStringStream;\n    \n    hexStringStream << std::hex << std::setfill('0');\n    for(size_t index = 0; index < dataLength; ++index)\n        hexStringStream << std::setw(2) << static_cast<int>(byteData[index]);\n    dest = hexStringStream.str();\n}\n\n\n// ------------------------------------------------------------------\n/*!\n    Convert a hex string to a block of data\n*/\nvoid KittyUtils::fromHex(\n    const std::string &in,     //!< Input hex string\n    void *const data           //!< Data store\n    )\n{\n    size_t          length    = in.length();\n    unsigned char   *byteData = reinterpret_cast<unsigned char*>(data);\n    \n    std::stringstream hexStringStream; hexStringStream >> std::hex;\n    for(size_t strIndex = 0, dataIndex = 0; strIndex < length; ++dataIndex)\n    {\n        // Read out and convert the string two characters at a time\n        const char tmpStr[3] = { in[strIndex++], in[strIndex++], 0 };\n\n        // Reset and fill the string stream\n        hexStringStream.clear();\n        hexStringStream.str(tmpStr);\n\n        // Do the conversion\n        int tmpValue = 0;\n        hexStringStream >> tmpValue;\n        byteData[dataIndex] = static_cast<unsigned char>(tmpValue);\n    }\n}","size_bytes":2461},"app/src/main/jni/KittyMemory/MemoryBackup.cpp":{"content":"//\n//  MemoryBackup.cpp\n//\n//  Created by MJ (Ruit) on 4/19/20.\n//\n\n#include <Includes/obfuscate.h>\n#include \"MemoryBackup.h\"\n\n\nMemoryBackup::MemoryBackup() {\n  _address = 0;\n  _size    = 0;\n  _orig_code.clear();\n}\n\nMemoryBackup::MemoryBackup(const char *libraryName, uintptr_t address, size_t backup_size, bool useMapCache) {\n  MemoryBackup();\n\n  if (libraryName == NULL || address == 0 || backup_size < 1)\n    return;\n\n  _address = KittyMemory::getAbsoluteAddress(libraryName, address, useMapCache);\n  if(_address == 0) return;\n  \n  _size = backup_size;\n\n  _orig_code.resize(backup_size);\n\n  // backup current content\n  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), backup_size);\n}\n\n\nMemoryBackup::MemoryBackup(uintptr_t absolute_address, size_t backup_size) {\n  MemoryBackup();\n\n  if (absolute_address == 0 || backup_size < 1)\n    return;\n\n  _address = absolute_address;\n  \n  _size = backup_size;\n\n  _orig_code.resize(backup_size);\n\n  // backup current content\n  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), backup_size);\n}\n\n   MemoryBackup::~MemoryBackup() {\n     // clean up\n     _orig_code.clear();\n   }\n\n\n  bool MemoryBackup::isValid() const {\n    return (_address != 0 && _size > 0\n            && _orig_code.size() == _size);\n  }\n\n  size_t MemoryBackup::get_BackupSize() const{\n    return _size;\n  }\n\n  uintptr_t MemoryBackup::get_TargetAddress() const{\n    return _address;\n  }\n\n  bool MemoryBackup::Restore() {\n    if (!isValid()) return false;\n    return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_orig_code[0], _size) == Memory_Status::SUCCESS;\n  }\n\n  std::string MemoryBackup::get_CurrBytes() {\n    if (!isValid()) \n      _hexString = std::string(OBFUSCATE(\"0xInvalid\"));\n      else \n      _hexString = KittyMemory::read2HexStr(reinterpret_cast<const void *>(_address), _size);\n\n    return _hexString;\n  }\n","size_bytes":1903},"app/src/main/jni/KittyMemory/MemoryPatch.cpp":{"content":"//\n//  MemoryPatch.cpp\n//\n//  Created by MJ (Ruit) on 1/1/19.\n//\n\n#include <Includes/obfuscate.h>\n#include \"MemoryPatch.h\"\n#include \"Includes/Logger.h\"\n\nMemoryPatch::MemoryPatch() {\n    _address = 0;\n    _size = 0;\n    _orig_code.clear();\n    _patch_code.clear();\n}\n\nMemoryPatch::MemoryPatch(const char *libraryName, uintptr_t address,\n                         const void *patch_code, size_t patch_size, bool useMapCache) {\n    MemoryPatch();\n\n    if (libraryName == NULL || address == 0 || patch_code == NULL || patch_size < 1)\n        return;\n\n    _address = KittyMemory::getAbsoluteAddress(libraryName, address, useMapCache);\n    if (_address == 0) return;\n\n    _size = patch_size;\n\n    _orig_code.resize(patch_size);\n    _patch_code.resize(patch_size);\n\n    // initialize patch & backup current content\n    KittyMemory::memRead(&_patch_code[0], patch_code, patch_size);\n    KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), patch_size);\n}\n\nMemoryPatch::MemoryPatch(uintptr_t absolute_address,\n                         const void *patch_code, size_t patch_size) {\n    MemoryPatch();\n\n    if (absolute_address == 0 || patch_code == NULL || patch_size < 1)\n        return;\n\n    _address = absolute_address;\n    _size = patch_size;\n\n    _orig_code.resize(patch_size);\n    _patch_code.resize(patch_size);\n\n    // initialize patch & backup current content\n    KittyMemory::memRead(&_patch_code[0], patch_code, patch_size);\n    KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), patch_size);\n}\n\nMemoryPatch::~MemoryPatch() {\n    // clean up\n    _orig_code.clear();\n    _patch_code.clear();\n}\n\nMemoryPatch MemoryPatch::createWithHex(const char *libraryName, uintptr_t address,\n                                       std::string hex, bool useMapCache) {\n    MemoryPatch patch;\n\n    if (libraryName == NULL || address == 0 || !KittyUtils::validateHexString(hex))\n        return patch;\n\n    patch._address = KittyMemory::getAbsoluteAddress(libraryName, address, useMapCache);\n    if (patch._address == 0) return patch;\n\n    patch._size = hex.length() / 2;\n\n    patch._orig_code.resize(patch._size);\n    patch._patch_code.resize(patch._size);\n\n    // initialize patch\n    KittyUtils::fromHex(hex, &patch._patch_code[0]);\n\n    // backup current content\n    KittyMemory::memRead(&patch._orig_code[0], reinterpret_cast<const void *>(patch._address),\n                         patch._size);\n    return patch;\n}\n\nMemoryPatch MemoryPatch::createWithHex(uintptr_t absolute_address, std::string hex) {\n    MemoryPatch patch;\n\n    if (absolute_address == 0 || !KittyUtils::validateHexString(hex))\n        return patch;\n\n    patch._address = absolute_address;\n    patch._size = hex.length() / 2;\n\n    patch._orig_code.resize(patch._size);\n    patch._patch_code.resize(patch._size);\n\n    // initialize patch\n    KittyUtils::fromHex(hex, &patch._patch_code[0]);\n\n    // backup current content\n    KittyMemory::memRead(&patch._orig_code[0], reinterpret_cast<const void *>(patch._address),\n                         patch._size);\n    return patch;\n}\n\nbool MemoryPatch::isValid() const {\n    return (_address != 0 && _size > 0\n            && _orig_code.size() == _size && _patch_code.size() == _size);\n}\n\nsize_t MemoryPatch::get_PatchSize() const {\n    return _size;\n}\n\nuintptr_t MemoryPatch::get_TargetAddress() const {\n    return _address;\n}\n\nbool MemoryPatch::Restore() {\n    if (!isValid()) return false;\n    //LOGI(\"Restore %i\", isLeeched);\n    return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_orig_code[0], _size) ==\n           Memory_Status::SUCCESS;\n}\n\nbool MemoryPatch::Modify() {\n    if (!isValid()) return false;\n    //LOGI(\"Modify\");\n    return (KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_patch_code[0], _size) ==\n            Memory_Status::SUCCESS);\n}\n\nstd::string MemoryPatch::get_CurrBytes() {\n    if (!isValid())\n        _hexString = std::string(OBFUSCATE(\"0xInvalid\"));\n    else\n        _hexString = KittyMemory::read2HexStr(reinterpret_cast<const void *>(_address), _size);\n\n    return _hexString;\n}\n","size_bytes":4085},"app/src/main/jni/Substrate/SubstrateDebug.cpp":{"content":"/* Cydia Substrate - Powerful Code Insertion Platform\n * Copyright (C) 2008-2011  Jay Freeman (saurik)\n*/\n\n/* GNU Lesser General Public License, Version 3 {{{ */\n/*\n * Substrate is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the\n * Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n *\n * Substrate is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.\n**/\n/* }}} */\n\n#include \"SubstrateHook.h\"\n#include \"SubstrateDebug.hpp\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <Includes/obfuscate.h>\n\n_extern bool MSDebug;\nbool MSDebug = false;\n\nstatic char _MSHexChar(uint8_t value) {\n    return value < 0x20 || value >= 0x80 ? '.' : value;\n}\n\n#define HexWidth_ 16\n#define HexDepth_ 4\n\nvoid MSLogHexEx(const void *vdata, size_t size, size_t stride, const char *mark) {\n    const uint8_t *data((const uint8_t *) vdata);\n\n    size_t i(0), j;\n\n    char d[256];\n    size_t b(0);\n    d[0] = '\\0';\n\n    while (i != size) {\n        if (i % HexWidth_ == 0) {\n            if (mark != NULL)\n                b += sprintf(d + b, OBFUSCATE(\"\\n[%s] \"), mark);\n            b += sprintf(d + b, OBFUSCATE(\"0x%.3zx:\"), i);\n        }\n\n        b += sprintf(d + b, \" \");\n\n        for (size_t q(0); q != stride; ++q)\n            b += sprintf(d + b, OBFUSCATE(\"%.2x\"), data[i + stride - q - 1]);\n\n        i += stride;\n\n        for (size_t q(1); q != stride; ++q)\n            b += sprintf(d + b, \" \");\n\n        if (i % HexDepth_ == 0)\n            b += sprintf(d + b, \" \");\n\n        if (i % HexWidth_ == 0) {\n            b += sprintf(d + b, \" \");\n            for (j = i - HexWidth_; j != i; ++j)\n                b += sprintf(d + b, \"%c\", _MSHexChar(data[j]));\n\n            lprintf(\"%s\", d);\n            b = 0;\n            d[0] = '\\0';\n        }\n    }\n\n    if (i % HexWidth_ != 0) {\n        for (j = i % HexWidth_; j != HexWidth_; ++j)\n            b += sprintf(d + b, \"   \");\n        for (j = 0; j != (HexWidth_ - i % HexWidth_ + HexDepth_ - 1) / HexDepth_; ++j)\n            b += sprintf(d + b, \" \");\n        b += sprintf(d + b, \" \");\n        for (j = i / HexWidth_ * HexWidth_; j != i; ++j)\n            b += sprintf(d + b, OBFUSCATE(\"%c\"), _MSHexChar(data[j]));\n\n       // lprintf(\"%s\", d);\n        b = 0;\n        d[0] = '\\0';\n    }\n}\n\nvoid MSLogHex(const void *vdata, size_t size, const char *mark) {\n    return MSLogHexEx(vdata, size, 1, mark);\n}\n","size_bytes":2812},"app/src/main/jni/Substrate/SubstrateHook.cpp":{"content":"/* Cydia Substrate - Powerful Code Insertion Platform\n * Copyright (C) 2008-2011  Jay Freeman (saurik)\n*/\n\n/* GNU Lesser General Public License, Version 3 {{{ */\n/*\n * Substrate is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the\n * Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n *\n * Substrate is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.\n**/\n/* }}} */\n\n#define SubstrateInternal\n\n#include \"CydiaSubstrate.h\"\n\n#include <sys/mman.h>\n\n#define _trace() do { \\\n    MSLog(MSLogLevelNotice, \"_trace(%u)\", __LINE__); \\\n} while (false)\n\n#if defined(__i386__) || defined(__x86_64__)\n\n#include \"hde64.h\"\n\n#endif\n\n#include \"SubstrateDebug.hpp\"\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <Includes/obfuscate.h>\n\n#ifdef __arm__\n/* WebCore (ARM) PC-Relative:\nX    1  ldr r*,[pc,r*] !=\n     2 fldd d*,[pc,#*]\nX    5  str r*,[pc,r*] !=\n     8 flds s*,[pc,#*]\n   400  ldr r*,[pc,r*] ==\n   515  add r*, pc,r*  ==\nX 4790  ldr r*,[pc,#*]    */\n\n// x=0; while IFS= read -r line; do if [[ ${#line} -ne 0 && $line == +([^\\;]): ]]; then x=2; elif [[ $line == ' +'* && $x -ne 0 ]]; then ((--x)); echo \"$x${line}\"; fi; done <WebCore.asm >WebCore.pc\n// grep pc WebCore.pc | cut -c 40- | sed -Ee 's/^ldr *(ip|r[0-9]*),\\[pc,\\#0x[0-9a-f]*\\].*/ ldr r*,[pc,#*]/;s/^add *r[0-9]*,pc,r[0-9]*.*/ add r*, pc,r*/;s/^(st|ld)r *r([0-9]*),\\[pc,r([0-9]*)\\].*/ \\1r r\\2,[pc,r\\3]/;s/^fld(s|d) *(s|d)[0-9]*,\\[pc,#0x[0-9a-f]*].*/fld\\1 \\2*,[pc,#*]/' | sort | uniq -c | sort -n\n\n#include \"SubstrateARM.hpp\"\n\n#define T$Label(l, r) \\\n    (((r) - (l)) * 2 - 4 + ((l) % 2 == 0 ? 0 : 2))\n\n#define T$pop_$r0$ 0xbc01 // pop {r0}\n#define T$b(im) /* b im */ \\\n    (0xde00 | (im & 0xff))\n#define T$blx(rm) /* blx rm */ \\\n    (0x4780 | (rm << 3))\n#define T$bx(rm) /* bx rm */ \\\n    (0x4700 | (rm << 3))\n#define T$nop /* nop */ \\\n    (0x46c0)\n\n#define T$add_rd_rm(rd, rm) /* add rd, rm */ \\\n    (0x4400 | (((rd) & 0x8) >> 3 << 7) | (((rm) & 0x8) >> 3 << 6) | (((rm) & 0x7) << 3) | ((rd) & 0x7))\n#define T$push_r(r) /* push r... */ \\\n    (0xb400 | (((r) & (1 << A$lr)) >> A$lr << 8) | ((r) & 0xff))\n#define T$pop_r(r) /* pop r... */ \\\n    (0xbc00 | (((r) & (1 << A$pc)) >> A$pc << 8) | ((r) & 0xff))\n#define T$mov_rd_rm(rd, rm) /* mov rd, rm */ \\\n    (0x4600 | (((rd) & 0x8) >> 3 << 7) | (((rm) & 0x8) >> 3 << 6) | (((rm) & 0x7) << 3) | ((rd) & 0x7))\n#define T$ldr_rd_$rn_im_4$(rd, rn, im) /* ldr rd, [rn, #im * 4] */ \\\n    (0x6800 | (((im) & 0x1f) << 6) | ((rn) << 3) | (rd))\n#define T$ldr_rd_$pc_im_4$(rd, im) /* ldr rd, [PC, #im * 4] */ \\\n    (0x4800 | ((rd) << 8) | ((im) & 0xff))\n#define T$cmp_rn_$im(rn, im) /* cmp rn, #im */ \\\n    (0x2000 | ((rn) << 8) | ((im) & 0xff))\n#define T$it$_cd(cd, ms) /* it<ms>, cd */ \\\n    (0xbf00 | ((cd) << 4) | (ms))\n#define T$cbz$_rn_$im(op,rn,im) /* cb<op>z rn, #im */ \\\n    (0xb100 | ((op) << 11) | (((im) & 0x40) >> 6 << 9) | (((im) & 0x3e) >> 1 << 3) | (rn))\n#define T$b$_$im(cond,im) /* b<cond> #im */ \\\n    (cond == A$al ? 0xe000 | (((im) >> 1) & 0x7ff) : 0xd000 | ((cond) << 8) | (((im) >> 1) & 0xff))\n\n#define T1$ldr_rt_$rn_im$(rt, rn, im) /* ldr rt, [rn, #im] */ \\\n    (0xf850 | ((im < 0 ? 0 : 1) << 7) | (rn))\n#define T2$ldr_rt_$rn_im$(rt, rn, im) /* ldr rt, [rn, #im] */ \\\n    (((rt) << 12) | abs((int)(im)))\n\n#define T1$mrs_rd_apsr(rd) /* mrs rd, apsr */ \\\n    (0xf3ef)\n#define T2$mrs_rd_apsr(rd) /* mrs rd, apsr */ \\\n    (0x8000 | ((rd) << 8))\n\n#define T1$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \\\n    (0xf380 | (rn))\n#define T2$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \\\n    (0x8c00)\n#define T$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \\\n    (T2$msr_apsr_nzcvqg_rn(rn) << 16 | T1$msr_apsr_nzcvqg_rn(rn))\n\nstatic inline bool A$pcrel$r(uint32_t ic) {\n    return (ic & 0x0c000000) == 0x04000000 && (ic & 0xf0000000) != 0xf0000000 && (ic & 0x000f0000) == 0x000f0000;\n}\n\nstatic inline bool T$32bit$i(uint16_t ic) {\n    return ((ic & 0xe000) == 0xe000 && (ic & 0x1800) != 0x0000);\n}\n\nstatic inline bool T$pcrel$cbz(uint16_t ic) {\n    return (ic & 0xf500) == 0xb100;\n}\n\nstatic inline bool T$pcrel$b(uint16_t ic) {\n    return (ic & 0xf000) == 0xd000 && (ic & 0x0e00) != 0x0e00;\n}\n\nstatic inline bool T2$pcrel$b(uint16_t *ic) {\n    return (ic[0] & 0xf800) == 0xf000 && (((ic[1] & 0xd000) == 0x9000 || (ic[1] & 0xd000) == 0x8000) && (ic[0] & 0x0380) != 0x0380);\n}\n\nstatic inline bool T$pcrel$bl(uint16_t *ic) {\n    return (ic[0] & 0xf800) == 0xf000 && ((ic[1] & 0xd000) == 0xd000 || (ic[1] & 0xd001) == 0xc000);\n}\n\nstatic inline bool T$pcrel$ldr(uint16_t ic) {\n    return (ic & 0xf800) == 0x4800;\n}\n\nstatic inline bool T$pcrel$add(uint16_t ic) {\n    return (ic & 0xff78) == 0x4478;\n}\n\nstatic inline bool T$pcrel$ldrw(uint16_t ic) {\n    return (ic & 0xff7f) == 0xf85f;\n}\n\nstatic size_t MSGetInstructionWidthThumb(void *start) {\n    uint16_t *thumb(reinterpret_cast<uint16_t *>(start));\n    return T$32bit$i(thumb[0]) ? 4 : 2;\n}\n\nstatic size_t MSGetInstructionWidthARM(void *start) {\n    return 4;\n}\n\nextern \"C\" size_t MSGetInstructionWidth(void *start) {\n    if ((reinterpret_cast<uintptr_t>(start) & 0x1) == 0)\n        return MSGetInstructionWidthARM(start);\n    else\n        return MSGetInstructionWidthThumb(reinterpret_cast<void *>(reinterpret_cast<uintptr_t>(start) & ~0x1));\n}\n\nstatic size_t SubstrateHookFunctionThumb(SubstrateProcessRef process, void *symbol, void *replace, void **result) {\n    if (symbol == NULL)\n        return 0;\nprintf(OBFUSCATE(\"SubstrateHookFunctionThumb\\n\"));\n    uint16_t *area(reinterpret_cast<uint16_t *>(symbol));\n\n    unsigned align((reinterpret_cast<uintptr_t>(area) & 0x2) == 0 ? 0 : 1);\n    uint16_t *thumb(area + align);\n\n    uint32_t *arm(reinterpret_cast<uint32_t *>(thumb + 2));\n    uint16_t *trail(reinterpret_cast<uint16_t *>(arm + 2));\n\n    if (\n        (align == 0 || area[0] == T$nop) &&\n        thumb[0] == T$bx(A$pc) &&\n        thumb[1] == T$nop &&\n        arm[0] == A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8)\n    ) {\n        if (result != NULL)\n            *result = reinterpret_cast<void *>(arm[1]);\n\n        SubstrateHookMemory code(process, arm + 1, sizeof(uint32_t) * 1);\n\n        arm[1] = reinterpret_cast<uint32_t>(replace);\n\n        return sizeof(arm[0]);\n    }\n\n    size_t required((trail - area) * sizeof(uint16_t));\n\n    size_t used(0);\n    while (used < required)\n        used += MSGetInstructionWidthThumb(reinterpret_cast<uint8_t *>(area) + used);\n    used = (used + sizeof(uint16_t) - 1) / sizeof(uint16_t) * sizeof(uint16_t);\n\n    size_t blank((used - required) / sizeof(uint16_t));\n\n    uint16_t backup[used / sizeof(uint16_t)];\n    memcpy(backup, area, used);\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", area);\n        MSLogHexEx(area, used + sizeof(uint16_t), 2, name);\n    }\n\n    if (result != NULL) {\n\n    size_t length(used);\n    for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset)\n        if (T$pcrel$ldr(backup[offset]))\n            length += 3 * sizeof(uint16_t);\n        else if (T$pcrel$b(backup[offset]))\n            length += 6 * sizeof(uint16_t);\n        else if (T2$pcrel$b(backup + offset)) {\n            length += 5 * sizeof(uint16_t);\n            ++offset;\n        } else if (T$pcrel$bl(backup + offset)) {\n            length += 5 * sizeof(uint16_t);\n            ++offset;\n        } else if (T$pcrel$cbz(backup[offset])) {\n            length += 16 * sizeof(uint16_t);\n        } else if (T$pcrel$ldrw(backup[offset])) {\n            length += 4 * sizeof(uint16_t);\n            ++offset;\n        } else if (T$pcrel$add(backup[offset]))\n            length += 6 * sizeof(uint16_t);\n        else if (T$32bit$i(backup[offset]))\n            ++offset;\n\n    unsigned pad((length & 0x2) == 0 ? 0 : 1);\n    length += (pad + 2) * sizeof(uint16_t) + 2 * sizeof(uint32_t);\n\n    uint16_t *buffer(reinterpret_cast<uint16_t *>(mmap(\n        NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0\n    )));\n\n    if (buffer == MAP_FAILED) {\n        MSLog(MSLogLevelError, \"MS:Error:mmap() = %d\", errno);\n        *result = NULL;\n        return 0;\n    }\n\n    if (false) fail: {\n        munmap(buffer, length);\n        *result = NULL;\n        return 0;\n    }\n\n    size_t start(pad), end(length / sizeof(uint16_t));\n    uint32_t *trailer(reinterpret_cast<uint32_t *>(buffer + end));\n    for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset) {\n        if (T$pcrel$ldr(backup[offset])) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t immediate : 8;\n                    uint16_t rd : 3;\n                    uint16_t : 5;\n                };\n            } bits = {backup[offset+0]};\n\n            buffer[start+0] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start+0, end-2) / 4);\n            buffer[start+1] = T$ldr_rd_$rn_im_4$(bits.rd, bits.rd, 0);\n\n            // XXX: this code \"works\", but is \"wrong\": the mechanism is more complex than this\n            *--trailer = ((reinterpret_cast<uint32_t>(area + offset) + 4) & ~0x2) + bits.immediate * 4;\n\n            start += 2;\n            end -= 2;\n        } else if (T$pcrel$b(backup[offset])) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t imm8 : 8;\n                    uint16_t cond : 4;\n                    uint16_t /*1101*/ : 4;\n                };\n            } bits = {backup[offset+0]};\n\n            intptr_t jump(bits.imm8 << 1);\n            jump |= 1;\n            jump <<= 23;\n            jump >>= 23;\n\n            buffer[start+0] = T$b$_$im(bits.cond, (end-6 - (start+0)) * 2 - 4);\n\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;\n            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n            *--trailer = T$nop << 16 | T$bx(A$pc);\n\n            start += 1;\n            end -= 6;\n        } else if (T2$pcrel$b(backup + offset)) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t imm6 : 6;\n                    uint16_t cond : 4;\n                    uint16_t s : 1;\n                    uint16_t : 5;\n                };\n            } bits = {backup[offset+0]};\n\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t imm11 : 11;\n                    uint16_t j2 : 1;\n                    uint16_t a : 1;\n                    uint16_t j1 : 1;\n                    uint16_t : 2;\n                };\n            } exts = {backup[offset+1]};\n\n            intptr_t jump(1);\n            jump |= exts.imm11 << 1;\n            jump |= bits.imm6 << 12;\n\n            if (exts.a) {\n                jump |= bits.s << 24;\n                jump |= (~(bits.s ^ exts.j1) & 0x1) << 23;\n                jump |= (~(bits.s ^ exts.j2) & 0x1) << 22;\n                jump |= bits.cond << 18;\n                jump <<= 7;\n                jump >>= 7;\n            } else {\n                jump |= bits.s << 20;\n                jump |= exts.j2 << 19;\n                jump |= exts.j1 << 18;\n                jump <<= 11;\n                jump >>= 11;\n            }\n\n            buffer[start+0] = T$b$_$im(exts.a ? A$al : bits.cond, (end-6 - (start+0)) * 2 - 4);\n\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;\n            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n            *--trailer = T$nop << 16 | T$bx(A$pc);\n\n            ++offset;\n            start += 1;\n            end -= 6;\n        } else if (T$pcrel$bl(backup + offset)) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t immediate : 10;\n                    uint16_t s : 1;\n                    uint16_t : 5;\n                };\n            } bits = {backup[offset+0]};\n\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t immediate : 11;\n                    uint16_t j2 : 1;\n                    uint16_t x : 1;\n                    uint16_t j1 : 1;\n                    uint16_t : 2;\n                };\n            } exts = {backup[offset+1]};\n\n            int32_t jump(0);\n            jump |= bits.s << 24;\n            jump |= (~(bits.s ^ exts.j1) & 0x1) << 23;\n            jump |= (~(bits.s ^ exts.j2) & 0x1) << 22;\n            jump |= bits.immediate << 12;\n            jump |= exts.immediate << 1;\n            jump |= exts.x;\n            jump <<= 7;\n            jump >>= 7;\n\n            buffer[start+0] = T$push_r(1 << A$r7);\n            buffer[start+1] = T$ldr_rd_$pc_im_4$(A$r7, ((end-2 - (start+1)) * 2 - 4 + 2) / 4);\n            buffer[start+2] = T$mov_rd_rm(A$lr, A$r7);\n            buffer[start+3] = T$pop_r(1 << A$r7);\n            buffer[start+4] = T$blx(A$lr);\n\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;\n\n            ++offset;\n            start += 5;\n            end -= 2;\n        } else if (T$pcrel$cbz(backup[offset])) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t rn : 3;\n                    uint16_t immediate : 5;\n                    uint16_t : 1;\n                    uint16_t i : 1;\n                    uint16_t : 1;\n                    uint16_t op : 1;\n                    uint16_t : 4;\n                };\n            } bits = {backup[offset+0]};\n\n            intptr_t jump(1);\n            jump |= bits.i << 6;\n            jump |= bits.immediate << 1;\n\n            //jump <<= 24;\n            //jump >>= 24;\n\n            unsigned rn(bits.rn);\n            unsigned rt(rn == A$r7 ? A$r6 : A$r7);\n\n            buffer[start+0] = T$push_r(1 << rt);\n            buffer[start+1] = T1$mrs_rd_apsr(rt);\n            buffer[start+2] = T2$mrs_rd_apsr(rt);\n            buffer[start+3] = T$cbz$_rn_$im(bits.op, rn, (end-10 - (start+3)) * 2 - 4);\n            buffer[start+4] = T1$msr_apsr_nzcvqg_rn(rt);\n            buffer[start+5] = T2$msr_apsr_nzcvqg_rn(rt);\n            buffer[start+6] = T$pop_r(1 << rt);\n\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;\n            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n            *--trailer = T$nop << 16 | T$bx(A$pc);\n            *--trailer = T$nop << 16 | T$pop_r(1 << rt);\n            *--trailer = T$msr_apsr_nzcvqg_rn(rt);\n\n#if 0\n            if ((start & 0x1) == 0)\n                buffer[start++] = T$nop;\n            buffer[start++] = T$bx(A$pc);\n            buffer[start++] = T$nop;\n\n            uint32_t *arm(reinterpret_cast<uint32_t *>(buffer + start));\n            arm[0] = A$add(A$lr, A$pc, 1);\n            arm[1] = A$ldr_rd_$rn_im$(A$pc, A$pc, (trailer - arm) * sizeof(uint32_t) - 8);\n#endif\n\n            start += 7;\n            end -= 10;\n        } else if (T$pcrel$ldrw(backup[offset])) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t : 7;\n                    uint16_t u : 1;\n                    uint16_t : 8;\n                };\n            } bits = {backup[offset+0]};\n\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t immediate : 12;\n                    uint16_t rt : 4;\n                };\n            } exts = {backup[offset+1]};\n\n            buffer[start+0] = T1$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start+0, end-2));\n            buffer[start+1] = T2$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start+0, end-2));\n\n            buffer[start+2] = T1$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);\n            buffer[start+3] = T2$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);\n\n            // XXX: this code \"works\", but is \"wrong\": the mechanism is more complex than this\n            *--trailer = ((reinterpret_cast<uint32_t>(area + offset) + 4) & ~0x2) + (bits.u == 0 ? -exts.immediate : exts.immediate);\n\n            ++offset;\n            start += 4;\n            end -= 2;\n        } else if (T$pcrel$add(backup[offset])) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t rd : 3;\n                    uint16_t rm : 3;\n                    uint16_t h2 : 1;\n                    uint16_t h1 : 1;\n                    uint16_t : 8;\n                };\n            } bits = {backup[offset+0]};\n\n            if (bits.h1) {\n                MSLog(MSLogLevelError, \"MS:Error:pcrel(%u):add (rd > r7)\", offset);\n                goto fail;\n            }\n\n            unsigned rt(bits.rd == A$r7 ? A$r6 : A$r7);\n\n            buffer[start+0] = T$push_r(1 << rt);\n            buffer[start+1] = T$mov_rd_rm(rt, (bits.h1 << 3) | bits.rd);\n            buffer[start+2] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start+2, end-2) / 4);\n            buffer[start+3] = T$add_rd_rm((bits.h1 << 3) | bits.rd, rt);\n            buffer[start+4] = T$pop_r(1 << rt);\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4;\n\n            start += 5;\n            end -= 2;\n        } else if (T$32bit$i(backup[offset])) {\n            buffer[start++] = backup[offset];\n            buffer[start++] = backup[++offset];\n        } else {\n            buffer[start++] = backup[offset];\n        }\n    }\n\n    buffer[start++] = T$bx(A$pc);\n    buffer[start++] = T$nop;\n\n    uint32_t *transfer = reinterpret_cast<uint32_t *>(buffer + start);\n    transfer[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n    transfer[1] = reinterpret_cast<uint32_t>(area + used / sizeof(uint16_t)) + 1;\n\n    if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {\n        MSLog(MSLogLevelError, \"MS:Error:mprotect():%d\", errno);\n        return 0;\n    }\n\n    *result = reinterpret_cast<uint8_t *>(buffer + pad) + 1;\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", *result);\n        MSLogHexEx(buffer, length, 2, name);\n    }\n\n    }\n\n    {\n        SubstrateHookMemory code(process, area, used);\n\n        if (align != 0)\n            area[0] = T$nop;\n\n        thumb[0] = T$bx(A$pc);\n        thumb[1] = T$nop;\n\n        arm[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n        arm[1] = reinterpret_cast<uint32_t>(replace);\n\n        for (unsigned offset(0); offset != blank; ++offset)\n            trail[offset] = T$nop;\n    }\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", area);\n        MSLogHexEx(area, used + sizeof(uint16_t), 2, name);\n    }\n\n    return used;\n}\n\nstatic size_t SubstrateHookFunctionARM(SubstrateProcessRef process, void *symbol, void *replace, void **result) {\n    if (symbol == NULL)\n        return 0;\n    printf(OBFUSCATE(\"SubstrateHookFunctionARM\\n\"));\n    uint32_t *area(reinterpret_cast<uint32_t *>(symbol));\n    uint32_t *arm(area);\n\n    const size_t used(8);\n\n    uint32_t backup[used / sizeof(uint32_t)] = {arm[0], arm[1]};\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", area);\n        MSLogHexEx(area, used + sizeof(uint32_t), 4, name);\n    }\n\n    if (result != NULL) {\n\n    if (backup[0] == A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8)) {\n        *result = reinterpret_cast<void *>(backup[1]);\n\n        return sizeof(backup[0]);\n    }\n\n    size_t length(used);\n    for (unsigned offset(0); offset != used / sizeof(uint32_t); ++offset)\n        if (A$pcrel$r(backup[offset])) {\n            if ((backup[offset] & 0x02000000) == 0 || (backup[offset] & 0x0000f000 >> 12) != (backup[offset] & 0x0000000f))\n                length += 2 * sizeof(uint32_t);\n            else\n                length += 4 * sizeof(uint32_t);\n        }\n\n    length += 2 * sizeof(uint32_t);\n\n    uint32_t *buffer(reinterpret_cast<uint32_t *>(mmap(\n        NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0\n    )));\n\n    if (buffer == MAP_FAILED) {\n        MSLog(MSLogLevelError, \"MS:Error:mmap() = %d\", errno);\n        *result = NULL;\n        return 0;\n    }\n\n    if (false) fail: {\n        munmap(buffer, length);\n        *result = NULL;\n        return 0;\n    }\n\n    size_t start(0), end(length / sizeof(uint32_t));\n    uint32_t *trailer(reinterpret_cast<uint32_t *>(buffer + end));\n    for (unsigned offset(0); offset != used / sizeof(uint32_t); ++offset)\n        if (A$pcrel$r(backup[offset])) {\n            union {\n                uint32_t value;\n\n                struct {\n                    uint32_t rm : 4;\n                    uint32_t : 1;\n                    uint32_t shift : 2;\n                    uint32_t shiftamount : 5;\n                    uint32_t rd : 4;\n                    uint32_t rn : 4;\n                    uint32_t l : 1;\n                    uint32_t w : 1;\n                    uint32_t b : 1;\n                    uint32_t u : 1;\n                    uint32_t p : 1;\n                    uint32_t mode : 1;\n                    uint32_t type : 2;\n                    uint32_t cond : 4;\n                };\n            } bits = {backup[offset+0]}, copy(bits);\n\n            bool guard;\n            if (bits.mode == 0 || bits.rd != bits.rm) {\n                copy.rn = bits.rd;\n                guard = false;\n            } else {\n                copy.rn = bits.rm != A$r0 ? A$r0 : A$r1;\n                guard = true;\n            }\n\n            if (guard)\n                buffer[start++] = A$stmdb_sp$_$rs$((1 << copy.rn));\n\n            buffer[start+0] = A$ldr_rd_$rn_im$(copy.rn, A$pc, (end-1 - (start+0)) * 4 - 8);\n            buffer[start+1] = copy.value;\n\n            start += 2;\n\n            if (guard)\n                buffer[start++] = A$ldmia_sp$_$rs$((1 << copy.rn));\n\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 8;\n            end -= 1;\n        } else\n            buffer[start++] = backup[offset];\n\n    buffer[start+0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n    buffer[start+1] = reinterpret_cast<uint32_t>(area + used / sizeof(uint32_t));\n\n    if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {\n        MSLog(MSLogLevelError, OBFUSCATE(\"MS:Error:mprotect():%d\"), errno);\n        goto fail;\n    }\n\n    *result = buffer;\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", *result);\n        MSLogHexEx(buffer, length, 4, name);\n    }\n\n    }\n\n    {\n        SubstrateHookMemory code(process, symbol, used);\n\n        arm[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n        arm[1] = reinterpret_cast<uint32_t>(replace);\n    }\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", area);\n        MSLogHexEx(area, used + sizeof(uint32_t), 4, name);\n    }\n\n    return used;\n}\n\nstatic size_t SubstrateHookFunction(SubstrateProcessRef process, void *symbol, void *replace, void **result) {\n    if (MSDebug)\n        MSLog(MSLogLevelNotice, \"SubstrateHookFunction(%p, %p, %p, %p)\\n\", process, symbol, replace, result);\n    if ((reinterpret_cast<uintptr_t>(symbol) & 0x1) == 0)\n        return SubstrateHookFunctionARM(process, symbol, replace, result);\n    else\n        return SubstrateHookFunctionThumb(process, reinterpret_cast<void *>(reinterpret_cast<uintptr_t>(symbol) & ~0x1), replace, result);\n}\n#endif\n\n#if defined(__i386__) || defined(__x86_64__)\n\n#include \"SubstrateX86.hpp\"\n\nstatic size_t MSGetInstructionWidthIntel(void *start) {\n    hde64s decode;\n    return hde64_disasm(start, &decode);\n}\n\nstatic void\nSubstrateHookFunction(SubstrateProcessRef process, void *symbol, void *replace, void **result) {\n    if (MSDebug)\n     MSLog(MSLogLevelNotice, OBFUSCATE(\"MSHookFunction(%p, %p, %p)\\n\"), symbol, replace, result);\n    if (symbol == NULL)\n        return;\n\n    uintptr_t source(reinterpret_cast<uintptr_t>(symbol));\n    uintptr_t target(reinterpret_cast<uintptr_t>(replace));\n\n    uint8_t *area(reinterpret_cast<uint8_t *>(symbol));\n\n    size_t required(MSSizeOfJump(target, source));\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, OBFUSCATE(\"%p\"), area);\n        MSLogHex(area, 32, name);\n    }\n\n    size_t used(0);\n    while (used < required) {\n        size_t width(MSGetInstructionWidthIntel(area + used));\n        if (width == 0) {\n            //MSLog(MSLogLevelError, \"MS:Error:MSGetInstructionWidthIntel(%p) == 0\", area + used);\n            return;\n        }\n\n        used += width;\n    }\n\n    size_t blank(used - required);\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, OBFUSCATE(\"%p\"), area);\n        MSLogHex(area, used + sizeof(uint16_t), name);\n    }\n\n    uint8_t backup[used];\n    memcpy(backup, area, used);\n\n    if (result != NULL) {\n\n        if (backup[0] == 0xe9) {\n            *result = reinterpret_cast<void *>(source + 5 +\n                                               *reinterpret_cast<uint32_t *>(backup + 1));\n            return;\n        }\n\n        if (!ia32 && backup[0] == 0xff && backup[1] == 0x25) {\n            *result = *reinterpret_cast<void **>(source + 6 +\n                                                 *reinterpret_cast<uint32_t *>(backup + 2));\n            return;\n        }\n\n        size_t length(used + MSSizeOfJump(source + used));\n\n        for (size_t offset(0), width; offset != used; offset += width) {\n            hde64s decode;\n            hde64_disasm(backup + offset, &decode);\n            width = decode.len;\n            //_assert(width != 0 && offset + width <= used);\n\n#ifdef __LP64__\n            if ((decode.modrm & 0xc7) == 0x05) {\n                if (decode.opcode == 0x8b) {\n                    void *destiny(area + offset + width + int32_t(decode.disp.disp32));\n                    uint8_t reg(decode.rex_r << 3 | decode.modrm_reg);\n                    length -= decode.len;\n                    length += MSSizeOfPushPointer(destiny);\n                    length += MSSizeOfPop(reg);\n                    length += MSSizeOfMove64();\n                } else {\n                    MSLog(MSLogLevelError, \"MS:Error: Unknown RIP-Relative (%.2x %.2x)\", decode.opcode, decode.opcode2);\n                    continue;\n                }\n            } else\n#endif\n\n            if (backup[offset] == 0xe8) {\n                int32_t relative(*reinterpret_cast<int32_t *>(backup + offset + 1));\n                void *destiny(area + offset + decode.len + relative);\n\n                if (relative == 0) {\n                    length -= decode.len;\n                    length += MSSizeOfPushPointer(destiny);\n                } else {\n                    length += MSSizeOfSkip();\n                    length += MSSizeOfJump(destiny);\n                }\n            } else if (backup[offset] == 0xeb) {\n                length -= decode.len;\n                length += MSSizeOfJump(area + offset + decode.len +\n                                       *reinterpret_cast<int8_t *>(backup + offset + 1));\n            } else if (backup[offset] == 0xe9) {\n                length -= decode.len;\n                length += MSSizeOfJump(area + offset + decode.len +\n                                       *reinterpret_cast<int32_t *>(backup + offset + 1));\n            } else if (\n                    backup[offset] == 0xe3 ||\n                    (backup[offset] & 0xf0) == 0x70\n                // XXX: opcode2 & 0xf0 is 0x80?\n                    ) {\n                length += decode.len;\n                length += MSSizeOfJump(area + offset + decode.len +\n                                       *reinterpret_cast<int8_t *>(backup + offset + 1));\n            }\n        }\n\n        uint8_t *buffer(reinterpret_cast<uint8_t *>(mmap(\n                NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0\n        )));\n\n        if (buffer == MAP_FAILED) {\n            MSLog(MSLogLevelError, OBFUSCATE(\"MS:Error:mmap() = %d\"), errno);\n            *result = NULL;\n            return;\n        }\n\n        if (false)\n            fail:\n            {\n                munmap(buffer, length);\n                *result = NULL;\n                return;\n            }\n\n        {\n            uint8_t *current(buffer);\n\n            for (size_t offset(0), width; offset != used; offset += width) {\n                hde64s decode;\n                hde64_disasm(backup + offset, &decode);\n                width = decode.len;\n                //_assert(width != 0 && offset + width <= used);\n\n#ifdef __LP64__\n                if ((decode.modrm & 0xc7) == 0x05) {\n                    if (decode.opcode == 0x8b) {\n                        void *destiny(area + offset + width + int32_t(decode.disp.disp32));\n                        uint8_t reg(decode.rex_r << 3 | decode.modrm_reg);\n                        MSPushPointer(current, destiny);\n                        MSWritePop(current, reg);\n                        MSWriteMove64(current, reg, reg);\n                    } else {\n                        MSLog(MSLogLevelError, \"MS:Error: Unknown RIP-Relative (%.2x %.2x)\", decode.opcode, decode.opcode2);\n                        goto copy;\n                    }\n                } else\n#endif\n\n                if (backup[offset] == 0xe8) {\n                    int32_t relative(*reinterpret_cast<int32_t *>(backup + offset + 1));\n                    if (relative == 0)\n                        MSPushPointer(current, area + offset + decode.len);\n                    else {\n                        MSWrite<uint8_t>(current, 0xe8);\n                        MSWrite<int32_t>(current, MSSizeOfSkip());\n                        void *destiny(area + offset + decode.len + relative);\n                        MSWriteSkip(current, MSSizeOfJump(destiny, current + MSSizeOfSkip()));\n                        MSWriteJump(current, destiny);\n                    }\n                } else if (backup[offset] == 0xeb)\n                    MSWriteJump(current, area + offset + decode.len +\n                                         *reinterpret_cast<int8_t *>(backup + offset + 1));\n                else if (backup[offset] == 0xe9)\n                    MSWriteJump(current, area + offset + decode.len +\n                                         *reinterpret_cast<int32_t *>(backup + offset + 1));\n                else if (\n                        backup[offset] == 0xe3 ||\n                        (backup[offset] & 0xf0) == 0x70\n                        ) {\n                    MSWrite<uint8_t>(current, backup[offset]);\n                    MSWrite<uint8_t>(current, 2);\n                    MSWrite<uint8_t>(current, 0xeb);\n                    void *destiny(area + offset + decode.len +\n                                  *reinterpret_cast<int8_t *>(backup + offset + 1));\n                    MSWrite<uint8_t>(current, MSSizeOfJump(destiny, current + 1));\n                    MSWriteJump(current, destiny);\n                } else\n#ifdef __LP64__\n                    copy:\n#endif\n                {\n                    MSWrite(current, backup + offset, width);\n                }\n            }\n\n            MSWriteJump(current, area + used);\n        }\n\n        if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {\n            MSLog(MSLogLevelError, OBFUSCATE(\"MS:Error:mprotect():%d\"), errno);\n            goto fail;\n        }\n\n        *result = buffer;\n\n        if (MSDebug) {\n            char name[16];\n            sprintf(name, OBFUSCATE(\"%p\"), *result);\n            MSLogHex(buffer, length, name);\n        }\n\n    }\n\n    {\n        SubstrateHookMemory code(process, area, used);\n        uint8_t *current(area);\n        MSWriteJump(current, target);\n        for (unsigned offset(0); offset != blank; ++offset)\n            MSWrite<uint8_t>(current, 0x90);\n    }\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, OBFUSCATE(\"%p\"), area);\n        MSLogHex(area, used + sizeof(uint16_t), name);\n    }\n}\n\n#endif\n\nvoid MSHookFunction(void *symbol, void *replace, void **result) {\n#if defined(__i386__) || defined(__arm__)\n    SubstrateHookFunction(NULL, symbol, replace, result);\n#endif\n}\n\n#if defined(__APPLE__) && defined(__arm__)\n_extern void _Z14MSHookFunctionPvS_PS_(void *symbol, void *replace, void **result) {\n    return MSHookFunction(symbol, replace, result);\n}\n#endif\n","size_bytes":31967},"app/src/main/jni/Substrate/SubstratePosixMemory.cpp":{"content":"/* Cydia Substrate - Powerful Code Insertion Platform\n * Copyright (C) 2008-2011  Jay Freeman (saurik)\n*/\n\n/* GNU Lesser General Public License, Version 3 {{{ */\n/*\n * Substrate is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the\n * Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n *\n * Substrate is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.\n**/\n/* }}} */\n\n#define SubstrateInternal\n#include \"CydiaSubstrate.h\"\n#include \"SubstrateLog.hpp\"\n\n#include <sys/mman.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <Includes/obfuscate.h>\n\nextern \"C\" void __clear_cache (void *beg, void *end);\n\nstruct __SubstrateMemory {\n    void *address_;\n    size_t width_;\n\n    __SubstrateMemory(void *address, size_t width) :\n        address_(address),\n        width_(width)\n    {\n    }\n};\n\nextern \"C\" SubstrateMemoryRef SubstrateMemoryCreate(SubstrateAllocatorRef allocator, SubstrateProcessRef process, void *data, size_t size) {\n    if (allocator != NULL) {\n        MSLog(MSLogLevelError, OBFUSCATE(\"MS:Error:allocator != %d\"), 0);\n        return NULL;\n    }\n\n    if (size == 0)\n        return NULL;\n\n    int page(getpagesize());\n\n    uintptr_t base(reinterpret_cast<uintptr_t>(data) / page * page);\n    size_t width(((reinterpret_cast<uintptr_t>(data) + size - 1) / page + 1) * page - base);\n    void *address(reinterpret_cast<void *>(base));\n\n    if (mprotect(address, width, PROT_READ | PROT_WRITE | PROT_EXEC) == -1) {\n        MSLog(MSLogLevelError, OBFUSCATE(\"MS:Error:mprotect() = %d\"), errno);\n        return NULL;\n    }\n\n    return new __SubstrateMemory(address, width);\n}\n\nextern \"C\" void SubstrateMemoryRelease(SubstrateMemoryRef memory) {\n    if (mprotect(memory->address_, memory->width_, PROT_READ | PROT_WRITE | PROT_EXEC) == -1)\n        MSLog(MSLogLevelError,  OBFUSCATE(\"MS:Error:mprotect() = %d\"), errno);\n\n    __clear_cache(reinterpret_cast<char *>(memory->address_), reinterpret_cast<char *>(memory->address_) + memory->width_);\n\n    delete memory;\n}\n","size_bytes":2457},"app/src/main/jni/Substrate/SymbolFinder.cpp":{"content":"#include <stdio.h>\n#include <elf.h>\n#include <android/log.h>\n#include <malloc.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <cstring>\n#include <Includes/obfuscate.h>\n#include \"SymbolFinder.h\"\n\n#define TAG \"MSHook\"\n#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,  TAG, __VA_ARGS__)\n#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)\n/* memory map for libraries */\n#define MAX_NAME_LEN 256\n#define MEMORY_ONLY  \"[memory]\"\nstruct mm {\n    char name[MAX_NAME_LEN];\n    unsigned long start, end;\n};\n\ntypedef struct symtab *symtab_t;\nstruct symlist {\n    Elf32_Sym *sym; /* symbols */\n    char *str; /* symbol strings */\n    unsigned num; /* number of symbols */\n};\nstruct symtab {\n    struct symlist *st; /* \"static\" symbols */\n    struct symlist *dyn; /* dynamic symbols */\n};\n\nstatic void *xmalloc(size_t size) {\n    void *p;\n    p = malloc(size);\n    if (!p) {\n        printf(OBFUSCATE(\"Out of memory\\n\"));\n        exit(1);\n    }\n    return p;\n}\n\nstatic int my_pread(int fd, void *buf, size_t count, off_t offset) {\n    lseek(fd, offset, SEEK_SET);\n    return read(fd, buf, count);\n}\n\nstatic struct symlist *get_syms(int fd, Elf32_Shdr *symh, Elf32_Shdr *strh) {\n    struct symlist *sl, *ret;\n    int rv;\n\n    ret = NULL;\n    sl = (struct symlist *) xmalloc(sizeof(struct symlist));\n    sl->str = NULL;\n    sl->sym = NULL;\n\n    /* sanity */\n    if (symh->sh_size % sizeof(Elf32_Sym)) {\n        //printf(\"elf_error\\n\");\n        goto out;\n    }\n\n    /* symbol table */\n    sl->num = symh->sh_size / sizeof(Elf32_Sym);\n    sl->sym = (Elf32_Sym *) xmalloc(symh->sh_size);\n    rv = my_pread(fd, sl->sym, symh->sh_size, symh->sh_offset);\n    if (0 > rv) {\n        //perror(\"read\");\n        goto out;\n    }\n    if (rv != symh->sh_size) {\n        //printf(\"elf error\\n\");\n        goto out;\n    }\n\n    /* string table */\n    sl->str = (char *) xmalloc(strh->sh_size);\n    rv = my_pread(fd, sl->str, strh->sh_size, strh->sh_offset);\n    if (0 > rv) {\n        //perror(\"read\");\n        goto out;\n    }\n    if (rv != strh->sh_size) {\n        //printf(\"elf error\");\n        goto out;\n    }\n\n    ret = sl;\n    out:\n    return ret;\n}\n\nstatic int do_load(int fd, symtab_t symtab) {\n    int rv;\n    size_t size;\n    Elf32_Ehdr ehdr;\n    Elf32_Shdr *shdr = NULL, *p;\n    Elf32_Shdr *dynsymh, *dynstrh;\n    Elf32_Shdr *symh, *strh;\n    char *shstrtab = NULL;\n    int i;\n    int ret = -1;\n\n    /* elf header */\n    rv = read(fd, &ehdr, sizeof(ehdr));\n    if (0 > rv) {\n        LOGD(OBFUSCATE(\"read\\n\"));\n        goto out;\n    }\n    if (rv != sizeof(ehdr)) {\n        LOGD(OBFUSCATE(\"elf error 1\\n\"));\n        goto out;\n    }\n    if (strncmp((const char *) ELFMAG, (const char *) ehdr.e_ident, SELFMAG)) { /* sanity */\n        LOGD(OBFUSCATE(\"not an elf\\n\"));\n        goto out;\n    }\n    if (sizeof(Elf32_Shdr) != ehdr.e_shentsize) { /* sanity */\n        LOGD(OBFUSCATE(\"elf error 2\\n\"));\n        goto out;\n    }\n\n    /* section header table */\n    size = ehdr.e_shentsize * ehdr.e_shnum;\n    shdr = (Elf32_Shdr *) xmalloc(size);\n    rv = my_pread(fd, shdr, size, ehdr.e_shoff);\n    if (0 > rv) {\n        LOGD(OBFUSCATE(\"read\\n\"));\n        goto out;\n    }\n    if (rv != size) {\n        LOGD(OBFUSCATE(\"elf error 3 %d %d\\n\"), rv, size);\n        goto out;\n    }\n\n    /* section header string table */\n    size = shdr[ehdr.e_shstrndx].sh_size;\n    shstrtab = (char *) xmalloc(size);\n    rv = my_pread(fd, shstrtab, size, shdr[ehdr.e_shstrndx].sh_offset);\n    if (0 > rv) {\n        LOGD(OBFUSCATE(\"read\\n\"));\n        goto out;\n    }\n    if (rv != size) {\n        LOGD(OBFUSCATE(\"elf error 4 %d %d\\n\"), rv, size);\n        goto out;\n    }\n\n    /* symbol table headers */\n    symh = dynsymh = NULL;\n    strh = dynstrh = NULL;\n    for (i = 0, p = shdr; i < ehdr.e_shnum; i++, p++)\n        if (SHT_SYMTAB == p->sh_type) {\n            if (symh) {\n                LOGD(OBFUSCATE(\"too many symbol tables\\n\"));\n                goto out;\n            }\n            symh = p;\n        } else if (SHT_DYNSYM == p->sh_type) {\n            if (dynsymh) {\n                LOGD(OBFUSCATE(\"too many symbol tables\\n\"));\n                goto out;\n            }\n            dynsymh = p;\n        } else if (SHT_STRTAB == p->sh_type\n                   && !strncmp(shstrtab + p->sh_name, OBFUSCATE(\".strtab\"), 7)) {\n            if (strh) {\n                LOGD(OBFUSCATE(\"too many string tables\\n\"));\n                goto out;\n            }\n            strh = p;\n        } else if (SHT_STRTAB == p->sh_type\n                   && !strncmp(shstrtab + p->sh_name, OBFUSCATE(\".dynstr\"), 7)) {\n            if (dynstrh) {\n                LOGD(OBFUSCATE(\"too many string tables\\n\"));\n                goto out;\n            }\n            dynstrh = p;\n        }\n    /* sanity checks */\n    if ((!dynsymh && dynstrh) || (dynsymh && !dynstrh)) {\n        LOGD(OBFUSCATE(\"bad dynamic symbol table\\n\"));\n        goto out;\n    }\n    if ((!symh && strh) || (symh && !strh)) {\n        LOGD(OBFUSCATE(\"bad symbol table\\n\"));\n        goto out;\n    }\n    if (!dynsymh && !symh) {\n        LOGD(OBFUSCATE(\"no symbol table\\n\"));\n        goto out;\n    }\n\n    /* symbol tables */\n    if (dynsymh)\n        symtab->dyn = get_syms(fd, dynsymh, dynstrh);\n    if (symh)\n        symtab->st = get_syms(fd, symh, strh);\n    ret = 0;\n    out:\n    free(shstrtab);\n    free(shdr);\n    return ret;\n}\n\nstatic symtab_t load_symtab(char *filename) {\n    int fd;\n    symtab_t symtab;\n\n    symtab = (symtab_t) xmalloc(sizeof(*symtab));\n    memset(symtab, 0, sizeof(*symtab));\n\n    fd = open(filename, O_RDONLY);\n    if (0 > fd) {\n        LOGE(OBFUSCATE(\"%s open\\n\"), __func__);\n        return NULL;\n    }\n    if (0 > do_load(fd, symtab)) {\n        LOGE(OBFUSCATE(\"Error ELF parsing %s\\n\"), filename);\n        free(symtab);\n        symtab = NULL;\n    }\n    close(fd);\n    return symtab;\n}\n\nstatic int load_memmap(pid_t pid, struct mm *mm, int *nmmp) {\n    size_t buf_size = 0x40000;\n    char *p_buf = (char *) malloc(buf_size); // increase this if needed for larger \"maps\"\n    char name[MAX_NAME_LEN] = {0};\n    char *p;\n    unsigned long start, end;\n    struct mm *m;\n    int nmm = 0;\n    int fd, rv;\n    int i;\n\n    sprintf(p_buf, OBFUSCATE(\"/proc/%d/maps\"), pid);\n    fd = open(p_buf, O_RDONLY);\n    if (0 > fd) {\n        LOGE(OBFUSCATE(\"Can't open %s for reading\\n\"), p_buf);\n        free(p_buf);\n        return -1;\n    }\n\n    /* Zero to ensure data is null terminated */\n    memset(p_buf, 0, buf_size);\n\n    p = p_buf;\n    while (1) {\n        rv = read(fd, p, buf_size - (p - p_buf));\n        if (0 > rv) {\n            LOGE(OBFUSCATE(\"%s read\"), __FUNCTION__);\n            free(p_buf);\n            return -1;\n        }\n        if (0 == rv)\n            break;\n        p += rv;\n        if (p - p_buf >= buf_size) {\n            LOGE(OBFUSCATE(\"Too many memory mapping\\n\"));\n            free(p_buf);\n            return -1;\n        }\n    }\n    close(fd);\n\n    p = strtok(p_buf, \"\\n\");\n    m = mm;\n    while (p) {\n        /* parse current map line */\n        rv = sscanf(p, OBFUSCATE(\"%08lx-%08lx %*s %*s %*s %*s %s\\n\"), &start, &end, name);\n\n        p = strtok(NULL, \"\\n\");\n\n        if (rv == 2) {\n            m = &mm[nmm++];\n            m->start = start;\n            m->end = end;\n            memcpy(m->name, MEMORY_ONLY, sizeof(MEMORY_ONLY));\n            continue;\n        }\n\n        /* search backward for other mapping with same name */\n        for (i = nmm - 1; i >= 0; i--) {\n            m = &mm[i];\n            if (!strcmp(m->name, name))\n                break;\n        }\n\n        if (i >= 0) {\n            if (start < m->start)\n                m->start = start;\n            if (end > m->end)\n                m->end = end;\n        } else {\n            /* new entry */\n            m = &mm[nmm++];\n            m->start = start;\n            m->end = end;\n            memcpy(m->name, name, strlen(name));\n        }\n    }\n\n    *nmmp = nmm;\n    free(p_buf);\n    return 0;\n}\n\n/* Find libc in MM, storing no more than LEN-1 chars of\n its name in NAME and set START to its starting\n address.  If libc cannot be found return -1 and\n leave NAME and START untouched.  Otherwise return 0\n and null-terminated NAME. */\nstatic int find_libname(const char *libn, char *name, int len, unsigned long *start,\n                        struct mm *mm, int nmm) {\n    int i;\n    struct mm *m;\n    char *p;\n    for (i = 0, m = mm; i < nmm; i++, m++) {\n        if (!strcmp(m->name, MEMORY_ONLY))\n            continue;\n        p = strrchr(m->name, '/');\n        if (!p)\n            continue;\n        p++;\n        if (strncmp(libn, p, strlen(libn)))\n            continue;\n        p += strlen(libn);\n\n        /* here comes our crude test -> 'libc.so' or 'libc-[0-9]' */\n        if (!strncmp(OBFUSCATE(\"so\"), p, 2) || 1) // || (p[0] == '-' && isdigit(p[1])))\n            break;\n    }\n    if (i >= nmm)\n        /* not found */\n        return -1;\n\n    *start = m->start;\n    strncpy(name, m->name, len);\n    if (strlen(m->name) >= len)\n        name[len - 1] = '\\0';\n\n    mprotect((void *) m->start, m->end - m->start,\n             PROT_READ | PROT_WRITE | PROT_EXEC);\n    return 0;\n}\n\nstatic int lookup2(struct symlist *sl, unsigned char type, char *name,\n                   unsigned long *val) {\n    Elf32_Sym *p;\n    int len;\n    int i;\n\n    len = strlen(name);\n    for (i = 0, p = sl->sym; i < sl->num; i++, p++) {\n        //LOGD(\"name: %s %x\\n\", sl->str+p->st_name, p->st_value)\n        if (!strncmp(sl->str + p->st_name, name, len)\n            && *(sl->str + p->st_name + len) == 0\n            && ELF32_ST_TYPE(p->st_info) == type) {\n            //if (p->st_value != 0) {\n            *val = p->st_value;\n            return 0;\n            //}\n        }\n    }\n    return -1;\n}\n\nstatic int lookup_sym(symtab_t s, unsigned char type, char *name,\n                      unsigned long *val) {\n    if (s->dyn && !lookup2(s->dyn, type, name, val))\n        return 0;\n    if (s->st && !lookup2(s->st, type, name, val))\n        return 0;\n    return -1;\n}\n\nstatic int lookup_func_sym(symtab_t s, char *name, unsigned long *val) {\n    return lookup_sym(s, STT_FUNC, name, val);\n}\n\nint find_name(pid_t pid, const char *name, const char *libn,\n              unsigned long *addr) {\n    struct mm mm[1000] = {0};\n    unsigned long libcaddr;\n    int nmm;\n    char libc[1024] = {0};\n    symtab_t s;\n\n    if (0 > load_memmap(pid, mm, &nmm)) {\n        LOGD(OBFUSCATE(\"cannot read memory map\\n\"));\n        return -1;\n    }\n    if (0\n        > find_libname((char *) libn, (char *) libc, sizeof(libc),\n                       &libcaddr, mm, nmm)) {\n        LOGD(OBFUSCATE(\"cannot find lib: %s\\n\"), libn);\n        return -1;\n    }\n    //LOGD(\"lib: >%s<\\n\", libc)\n    s = load_symtab(libc);\n    if (!s) {\n        LOGD(OBFUSCATE(\"cannot read symbol table\\n\"));\n        return -1;\n    }\n    if (0 > lookup_func_sym(s, (char *) name, addr)) {\n        LOGD(OBFUSCATE(\"cannot find function: %s\\n\"), name);\n        return -1;\n    }\n    *addr += libcaddr;\n    return 0;\n}\n\nint find_libbase(pid_t pid, const char *libn, unsigned long *addr) {\n    struct mm mm[1000] = {0};\n    unsigned long libcaddr;\n    int nmm;\n    char libc[1024] = {0};\n    symtab_t s;\n\n    if (0 > load_memmap(pid, mm, &nmm)) {\n        LOGD(OBFUSCATE(\"cannot read memory map\\n\"));\n        return -1;\n    }\n    if (0 > find_libname(libn, libc, sizeof(libc), &libcaddr, mm, nmm)) {\n        LOGD(OBFUSCATE(\"cannot find lib\\n\"));\n        return -1;\n    }\n    *addr = libcaddr;\n    return 0;\n}\n","size_bytes":11467},"app/src/main/jni/Substrate/hde64.c":{"content":"/*\n * Hacker Disassembler Engine 64 C\n * Copyright (c) 2008-2009, Vyacheslav Patkov.\n * All rights reserved.\n *\n */\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"hde64.h\"\n#include \"table64.h\"\n\nunsigned int hde64_disasm(const void *code, hde64s *hs)\n{\n    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;\n    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;\n    uint8_t op64 = 0;\n\n    memset(hs,0,sizeof(hde64s));\n    char *tmp=(char*)hs;\n\n    for (x = 16; x; x--)\n        switch (c = *p++) {\n            case 0xf3:\n                hs->p_rep = c;\n                pref |= PRE_F3;\n                break;\n            case 0xf2:\n                hs->p_rep = c;\n                pref |= PRE_F2;\n                break;\n            case 0xf0:\n                hs->p_lock = c;\n                pref |= PRE_LOCK;\n                break;\n            case 0x26: case 0x2e: case 0x36:\n            case 0x3e: case 0x64: case 0x65:\n                hs->p_seg = c;\n                pref |= PRE_SEG;\n                break;\n            case 0x66:\n                hs->p_66 = c;\n                pref |= PRE_66;\n                break;\n            case 0x67:\n                hs->p_67 = c;\n                pref |= PRE_67;\n                break;\n            default:\n                goto pref_done;\n        }\n  pref_done:\n\n    hs->flags = (uint32_t)pref << 23;\n\n    if (!pref)\n        pref |= PRE_NONE;\n\n    if ((c & 0xf0) == 0x40) {\n        hs->flags |= F_PREFIX_REX;\n        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)\n            op64++;\n        hs->rex_r = (c & 7) >> 2;\n        hs->rex_x = (c & 3) >> 1;\n        hs->rex_b = c & 1;\n        if (((c = *p++) & 0xf0) == 0x40) {\n            opcode = c;\n            goto error_opcode;\n        }\n    }\n\n    if ((hs->opcode = c) == 0x0f) {\n        hs->opcode2 = c = *p++;\n        ht += DELTA_OPCODES;\n    } else if (c >= 0xa0 && c <= 0xa3) {\n        op64++;\n        if (pref & PRE_67)\n            pref |= PRE_66;\n        else\n            pref &= ~PRE_66;\n    }\n\n    opcode = c;\n    cflags = ht[ht[opcode / 4] + (opcode % 4)];\n\n    if (cflags == C_ERROR) {\n      error_opcode:\n        hs->flags |= F_ERROR | F_ERROR_OPCODE;\n        cflags = 0;\n        if ((opcode & -3) == 0x24)\n            cflags++;\n    }\n\n    x = 0;\n    if (cflags & C_GROUP) {\n        uint16_t t;\n        t = *(uint16_t *)(ht + (cflags & 0x7f));\n        cflags = (uint8_t)t;\n        x = (uint8_t)(t >> 8);\n    }\n\n    if (hs->opcode2) {\n        ht = hde64_table + DELTA_PREFIXES;\n        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)\n            hs->flags |= F_ERROR | F_ERROR_OPCODE;\n    }\n\n    if (cflags & C_MODRM) {\n        hs->flags |= F_MODRM;\n        hs->modrm = c = *p++;\n        hs->modrm_mod = m_mod = c >> 6;\n        hs->modrm_rm = m_rm = c & 7;\n        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;\n\n        if (x && ((x << m_reg) & 0x80))\n            hs->flags |= F_ERROR | F_ERROR_OPCODE;\n\n        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {\n            uint8_t t = opcode - 0xd9;\n            if (m_mod == 3) {\n                ht = hde64_table + DELTA_FPU_MODRM + t*8;\n                t = ht[m_reg] << m_rm;\n            } else {\n                ht = hde64_table + DELTA_FPU_REG;\n                t = ht[t] << m_reg;\n            }\n            if (t & 0x80)\n                hs->flags |= F_ERROR | F_ERROR_OPCODE;\n        }\n\n        if (pref & PRE_LOCK) {\n            if (m_mod == 3) {\n                hs->flags |= F_ERROR | F_ERROR_LOCK;\n            } else {\n                uint8_t *table_end, op = opcode;\n                if (hs->opcode2) {\n                    ht = hde64_table + DELTA_OP2_LOCK_OK;\n                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;\n                } else {\n                    ht = hde64_table + DELTA_OP_LOCK_OK;\n                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;\n                    op &= -2;\n                }\n                for (; ht != table_end; ht++)\n                    if (*ht++ == op) {\n                        if (!((*ht << m_reg) & 0x80))\n                            goto no_lock_error;\n                        else\n                            break;\n                    }\n                hs->flags |= F_ERROR | F_ERROR_LOCK;\n              no_lock_error:\n                ;\n            }\n        }\n\n        if (hs->opcode2) {\n            switch (opcode) {\n                case 0x20: case 0x22:\n                    m_mod = 3;\n                    if (m_reg > 4 || m_reg == 1)\n                        goto error_operand;\n                    else\n                        goto no_error_operand;\n                case 0x21: case 0x23:\n                    m_mod = 3;\n                    if (m_reg == 4 || m_reg == 5)\n                        goto error_operand;\n                    else\n                        goto no_error_operand;\n            }\n        } else {\n            switch (opcode) {\n                case 0x8c:\n                    if (m_reg > 5)\n                        goto error_operand;\n                    else\n                        goto no_error_operand;\n                case 0x8e:\n                    if (m_reg == 1 || m_reg > 5)\n                        goto error_operand;\n                    else\n                        goto no_error_operand;\n            }\n        }\n\n        if (m_mod == 3) {\n            uint8_t *table_end;\n            if (hs->opcode2) {\n                ht = hde64_table + DELTA_OP2_ONLY_MEM;\n                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;\n            } else {\n                ht = hde64_table + DELTA_OP_ONLY_MEM;\n                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;\n            }\n            for (; ht != table_end; ht += 2)\n                if (*ht++ == opcode) {\n                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))\n                        goto error_operand;\n                    else\n                        break;\n                }\n            goto no_error_operand;\n        } else if (hs->opcode2) {\n            switch (opcode) {\n                case 0x50: case 0xd7: case 0xf7:\n                    if (pref & (PRE_NONE | PRE_66))\n                        goto error_operand;\n                    break;\n                case 0xd6:\n                    if (pref & (PRE_F2 | PRE_F3))\n                        goto error_operand;\n                    break;\n                case 0xc5:\n                    goto error_operand;\n            }\n            goto no_error_operand;\n        } else\n            goto no_error_operand;\n\n      error_operand:\n        hs->flags |= F_ERROR | F_ERROR_OPERAND;\n      no_error_operand:\n\n        c = *p++;\n        if (m_reg <= 1) {\n            if (opcode == 0xf6)\n                cflags |= C_IMM8;\n            else if (opcode == 0xf7)\n                cflags |= C_IMM_P66;\n        }\n\n        switch (m_mod) {\n            case 0:\n                if (pref & PRE_67) {\n                    if (m_rm == 6)\n                        disp_size = 2;\n                } else\n                    if (m_rm == 5)\n                        disp_size = 4;\n                break;\n            case 1:\n                disp_size = 1;\n                break;\n            case 2:\n                disp_size = 2;\n                if (!(pref & PRE_67))\n                    disp_size <<= 1;\n        }\n\n        if (m_mod != 3 && m_rm == 4) {\n            hs->flags |= F_SIB;\n            p++;\n            hs->sib = c;\n            hs->sib_scale = c >> 6;\n            hs->sib_index = (c & 0x3f) >> 3;\n            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))\n                disp_size = 4;\n        }\n\n        p--;\n        switch (disp_size) {\n            case 1:\n                hs->flags |= F_DISP8;\n                hs->disp.disp8 = *p;\n                break;\n            case 2:\n                hs->flags |= F_DISP16;\n                hs->disp.disp16 = *(uint16_t *)p;\n                break;\n            case 4:\n                hs->flags |= F_DISP32;\n                hs->disp.disp32 = *(uint32_t *)p;\n        }\n        p += disp_size;\n    } else if (pref & PRE_LOCK)\n        hs->flags |= F_ERROR | F_ERROR_LOCK;\n\n    if (cflags & C_IMM_P66) {\n        if (cflags & C_REL32) {\n            if (pref & PRE_66) {\n                hs->flags |= F_IMM16 | F_RELATIVE;\n                hs->imm.imm16 = *(uint16_t *)p;\n                p += 2;\n                goto disasm_done;\n            }\n            goto rel32_ok;\n        }\n        if (op64) {\n            hs->flags |= F_IMM64;\n            hs->imm.imm64 = *(uint64_t *)p;\n            p += 8;\n        } else if (!(pref & PRE_66)) {\n            hs->flags |= F_IMM32;\n            hs->imm.imm32 = *(uint32_t *)p;\n            p += 4;\n        } else\n            goto imm16_ok;\n    }\n\n\n    if (cflags & C_IMM16) {\n      imm16_ok:\n        hs->flags |= F_IMM16;\n        hs->imm.imm16 = *(uint16_t *)p;\n        p += 2;\n    }\n    if (cflags & C_IMM8) {\n        hs->flags |= F_IMM8;\n        hs->imm.imm8 = *p++;\n    }\n\n    if (cflags & C_REL32) {\n      rel32_ok:\n        hs->flags |= F_IMM32 | F_RELATIVE;\n        hs->imm.imm32 = *(uint32_t *)p;\n        p += 4;\n    } else if (cflags & C_REL8) {\n        hs->flags |= F_IMM8 | F_RELATIVE;\n        hs->imm.imm8 = *p++;\n    }\n\n  disasm_done:\n\n    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {\n        hs->flags |= F_ERROR | F_ERROR_LENGTH;\n        hs->len = 15;\n    }\n\n    return (unsigned int)hs->len;\n}\n","size_bytes":9406},"app/src/main/java/uk/lgl/MainActivity.java":{"content":"package uk.lgl;\n\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.provider.Settings;\nimport android.widget.Toast;\n\nimport uk.lgl.modmenu.FloatingModMenuService;\n\npublic class MainActivity extends Activity {\n\n    //Only if you have changed MainActivity to yours and you wanna call game's activity.\n    public String GameActivity = \"com.unity3d.player.UnityPlayerActivity\";\n    public boolean hasLaunched = false;\n\n    //Load lib\n    static {\n        // When you change the lib name, change also on Android.mk file\n        // Both must have same name\n        System.loadLibrary(\"MyLibName\");\n    }\n\n    //To call onCreate, please refer to README.md\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        //To launch mod menu.\n        Start(this);\n\n        //To launch game activity\n        if (!hasLaunched) {\n            try {\n                //Start service\n                //MainActivity.this.startActivity(new Intent(MainActivity.this, Class.forName(MainActivity.this.GameActivity)));\n                MainActivity.this.startActivity(new Intent(MainActivity.this, Class.forName(MainActivity.this.GameActivity)));\n                hasLaunched = true;\n            } catch (ClassNotFoundException e) {\n                //Uncomment this if you are following METHOD 2 of CHANGING FILES\n                //Toast.makeText(MainActivity.this, \"Error. Game's main activity does not exist\", Toast.LENGTH_LONG).show();\n                e.printStackTrace();\n                return;\n            }\n        }\n    }\n\n    public static void Start(final Context context) {\n        //Check if overlay permission is enabled or not\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !Settings.canDrawOverlays(context)) {\n            Toast.makeText(context.getApplicationContext(), \"Overlay permission is required in order to show mod menu. Restart the game after you allow permission\", Toast.LENGTH_LONG).show();\n            Toast.makeText(context.getApplicationContext(), \"Overlay permission is required in order to show mod menu. Restart the game after you allow permission\", Toast.LENGTH_LONG).show();\n            context.startActivity(new Intent(\"android.settings.action.MANAGE_OVERLAY_PERMISSION\",\n                    Uri.parse(\"package:\" + context.getPackageName())));\n            final Handler handler = new Handler();\n            handler.postDelayed(new Runnable() {\n                @Override\n                public void run() {\n                    System.exit(1);\n                }\n            }, 5000);\n            return;\n        } else {\n            final Handler handler = new Handler();\n            handler.postDelayed(new Runnable() {\n                @Override\n                public void run() {\n                    context.startService(new Intent(context, FloatingModMenuService.class));\n                }\n            }, 500);\n        }\n    }\n}\n","size_bytes":3125},"app/src/main/java/uk/lgl/modmenu/FloatingModMenuService.java":{"content":"//Please don't replace listeners with lambda!\n\npackage uk.lgl.modmenu;\n\nimport android.animation.ValueAnimator;\nimport android.annotation.TargetApi;\nimport android.app.ActivityManager;\nimport android.app.ActivityManager.RunningAppProcessInfo;\nimport android.app.AlertDialog;\nimport android.app.Service;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.res.ColorStateList;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Color;\nimport android.graphics.PorterDuff;\nimport android.graphics.Typeface;\nimport android.graphics.drawable.GradientDrawable;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.text.Html;\nimport android.text.InputFilter;\nimport android.text.InputType;\nimport android.text.TextUtils;\nimport android.text.method.DigitsKeyListener;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.TypedValue;\nimport android.view.Gravity;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.WindowManager;\nimport android.view.inputmethod.InputMethodManager;\nimport android.webkit.WebView;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.CompoundButton;\nimport android.widget.EditText;\nimport android.widget.FrameLayout;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.RadioButton;\nimport android.widget.RadioGroup;\nimport android.widget.RelativeLayout;\nimport android.widget.ScrollView;\nimport android.widget.SeekBar;\nimport android.widget.Spinner;\nimport android.widget.Switch;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\nimport static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\nimport static android.widget.RelativeLayout.ALIGN_PARENT_LEFT;\nimport static android.widget.RelativeLayout.ALIGN_PARENT_RIGHT;\n\npublic class FloatingModMenuService extends Service {\n    //********** Here you can easly change the menu appearance **********//\n\n    //region Variable\n    public static final String TAG = \"Mod_Menu\"; //Tag for logcat\n    // ********** PREMIUM UI COLOR SCHEME **********\n    int TEXT_COLOR = Color.parseColor(\"#E8EAF6\");                    // Premium light purple-white\n    int TEXT_COLOR_2 = Color.parseColor(\"#FFFFFF\");                  // Pure white for contrast\n    int BTN_COLOR = Color.parseColor(\"#283593\");                     // Premium deep blue\n    int MENU_BG_COLOR = Color.parseColor(\"#F0121212\");               // Premium dark with high transparency\n    int MENU_FEATURE_BG_COLOR = Color.parseColor(\"#E0181818\");       // Slightly lighter dark background\n    int MENU_WIDTH = 250;                                            // Reduced width for compact design\n    int MENU_HEIGHT = 180;                                           // Reduced height for compact design\n    float MENU_CORNER = 12f;                                         // Modern rounded corners\n    int ICON_SIZE = 40;                                              // Slightly smaller, more refined icon\n    float ICON_ALPHA = 0.85f;                                       // More visible but elegant\n    int ToggleON = Color.parseColor(\"#4CAF50\");                      // Premium green\n    int ToggleOFF = Color.parseColor(\"#F44336\");                     // Premium red\n    int BtnON = Color.parseColor(\"#2E7D32\");                         // Premium dark green\n    int BtnOFF = Color.parseColor(\"#C62828\");                        // Premium dark red\n    int CategoryBG = Color.parseColor(\"#37474F\");                    // Premium blue-gray\n    int SeekBarColor = Color.parseColor(\"#5C6BC0\");                  // Premium indigo\n    int SeekBarProgressColor = Color.parseColor(\"#3F51B5\");          // Premium indigo accent\n    int CheckBoxColor = Color.parseColor(\"#7986CB\");                 // Premium light indigo\n    int RadioColor = Color.parseColor(\"#E8EAF6\");                    // Consistent with text color\n    String NumberTxtColor = \"#66BB6A\";                              // Premium green for numbers\n    //********************************************************************//\n    RelativeLayout mCollapsed, mRootContainer;\n    LinearLayout mExpanded, patches, mSettings, mCollapse, mThinBar; // Added thin bar for ImGui style\n    LinearLayout.LayoutParams scrlLLExpanded, scrlLL;\n    WindowManager mWindowManager;\n    WindowManager.LayoutParams params;\n    ImageView startimage;\n    FrameLayout rootFrame;\n    ScrollView scrollView;\n\n    boolean stopChecking;\n\n    //initialize methods from the native library\n    native void setTitleText(TextView textView);\n\n    native void setHeadingText(TextView textView);\n\n    native String Icon();\n\n    native String IconWebViewData();\n\n    native String[] getFeatureList();\n\n    native String[] settingsList();\n\n    native boolean isGameLibLoaded();\n    //endregion\n\n    //When this Class is called the code in this function will be executed\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Preferences.context = this;\n\n        //Create the menu\n        initFloating();\n\n        //Create a handler for this Class\n        final Handler handler = new Handler();\n        handler.post(new Runnable() {\n            public void run() {\n                Thread();\n                handler.postDelayed(this, 1000);\n            }\n        });\n    }\n\n    //Here we write the code for our Menu\n    // Reference: https://www.androidhive.info/2016/11/android-floating-widget-like-facebook-chat-head/\n    private void initFloating() {\n        rootFrame = new FrameLayout(this); // Global markup\n        rootFrame.setOnTouchListener(onTouchListener());\n        mRootContainer = new RelativeLayout(this); // Markup on which two markups of the icon and the menu itself will be placed\n        // Removed logo - thin bar shows directly\n        mCollapsed = new RelativeLayout(this); // No longer needed but keeping for compatibility\n        mCollapsed.setVisibility(View.GONE); // Hidden permanently\n\n        //********** The box of the mod menu **********\n        mExpanded = new LinearLayout(this); // Menu markup (when the menu is expanded)\n        mExpanded.setVisibility(View.GONE);\n        mExpanded.setBackgroundColor(MENU_BG_COLOR);\n        mExpanded.setOrientation(LinearLayout.VERTICAL);\n        // mExpanded.setPadding(1, 1, 1, 1); //So borders would be visible\n        mExpanded.setLayoutParams(new LinearLayout.LayoutParams(dp(MENU_WIDTH), WRAP_CONTENT));\n        // ********** PREMIUM GRADIENT DESIGN **********\n        GradientDrawable gdMenuBody = new GradientDrawable();\n        gdMenuBody.setCornerRadius(MENU_CORNER); //Modern rounded corners\n        gdMenuBody.setColor(MENU_BG_COLOR); //Premium dark background\n        gdMenuBody.setStroke(2, Color.parseColor(\"#5C6BC0\")); //Premium indigo border - thicker and more elegant\n        gdMenuBody.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n        // Create subtle gradient effect for premium look\n        gdMenuBody.setColors(new int[]{MENU_BG_COLOR, Color.parseColor(\"#E8121212\")});\n        mExpanded.setBackground(gdMenuBody); //Apply premium gradient design\n\n        // Logo removed - thin bar shows directly from start\n\n        // WebView logo completely removed - thin bar shows directly\n\n        //********** Close X button (ImGui style) **********\n        TextView closeButton = new TextView(this);\n        closeButton.setText(\"✕\"); // Clean X symbol for closing\n        closeButton.setTextColor(TEXT_COLOR);\n        closeButton.setTypeface(Typeface.DEFAULT_BOLD);\n        closeButton.setTextSize(16.0f); // Proportional size\n        RelativeLayout.LayoutParams rlClose = new RelativeLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT);\n        rlClose.addRule(ALIGN_PARENT_RIGHT);\n        closeButton.setLayoutParams(rlClose);\n        closeButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Hide menu with ImGui-style collapse to thin bar\n                mExpanded.setVisibility(View.GONE);\n                mThinBar.setVisibility(View.VISIBLE);\n            }\n        });\n\n        //********** ImGui-Style Thin Bar **********\n        mThinBar = new LinearLayout(this);\n        mThinBar.setOrientation(LinearLayout.HORIZONTAL);\n        mThinBar.setVisibility(View.VISIBLE); // Show thin bar immediately from start\n        mThinBar.setBackgroundColor(MENU_BG_COLOR);\n        mThinBar.setPadding(12, 8, 12, 8);\n        mThinBar.setLayoutParams(new LinearLayout.LayoutParams(dp(220), dp(35))); // Thin horizontal bar\n        \n        // Apply premium styling to thin bar\n        GradientDrawable gdThinBar = new GradientDrawable();\n        gdThinBar.setCornerRadius(8f); // Slightly rounded for modern look\n        gdThinBar.setColor(MENU_BG_COLOR);\n        gdThinBar.setStroke(1, Color.parseColor(\"#5C6BC0\")); // Premium border\n        mThinBar.setBackground(gdThinBar);\n        \n        // Expand button (at the beginning)\n        TextView expandBtn = new TextView(this);\n        expandBtn.setText(\"‣\"); // Arrow to expand - positioned first\n        expandBtn.setTextColor(TEXT_COLOR);\n        expandBtn.setTextSize(16.0f);\n        expandBtn.setTypeface(Typeface.DEFAULT_BOLD);\n        expandBtn.setGravity(Gravity.CENTER);\n        LinearLayout.LayoutParams expandParams = new LinearLayout.LayoutParams(dp(35), WRAP_CONTENT);\n        expandBtn.setLayoutParams(expandParams);\n        expandBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Expand to full menu\n                mThinBar.setVisibility(View.GONE);\n                mExpanded.setVisibility(View.VISIBLE);\n            }\n        });\n        \n        // Menu name text (centered)\n        TextView menuName = new TextView(this);\n        menuName.setText(\"HexCore V1\");\n        menuName.setTextColor(TEXT_COLOR);\n        menuName.setTextSize(13.0f);\n        menuName.setTypeface(Typeface.create(\"sans-serif-light\", Typeface.BOLD)); // Premium font\n        menuName.setGravity(Gravity.CENTER); // Center the text perfectly\n        LinearLayout.LayoutParams nameParams = new LinearLayout.LayoutParams(0, WRAP_CONTENT);\n        nameParams.weight = 1.0f; // Take up remaining space for centering\n        menuName.setLayoutParams(nameParams);\n        \n        // Empty spacer for perfect centering\n        TextView spacer = new TextView(this);\n        LinearLayout.LayoutParams spacerParams = new LinearLayout.LayoutParams(dp(35), WRAP_CONTENT);\n        spacer.setLayoutParams(spacerParams);\n        \n        mThinBar.addView(expandBtn); // Play button first\n        mThinBar.addView(menuName); // Text in center\n        mThinBar.addView(spacer); // Spacer for perfect balance\n        \n        //********** Settings **********\n        mSettings = new LinearLayout(this);\n        mSettings.setOrientation(LinearLayout.VERTICAL);\n        featureList(settingsList(), mSettings);\n\n        //********** Title text **********\n        RelativeLayout titleText = new RelativeLayout(this);\n        titleText.setPadding(12, 8, 12, 8); //More refined padding for compact design\n        titleText.setVerticalGravity(16);\n\n        TextView title = new TextView(this);\n        title.setTextColor(TEXT_COLOR);\n        title.setTextSize(16.0f); //Slightly smaller for refined look\n        title.setGravity(Gravity.CENTER);\n        RelativeLayout.LayoutParams rl = new RelativeLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT);\n        rl.addRule(RelativeLayout.CENTER_HORIZONTAL);\n        title.setLayoutParams(rl);\n        setTitleText(title);\n\n        //********** Heading text **********\n        TextView heading = new TextView(this);\n        //heading.setText(Html.fromHtml(Heading()));\n        heading.setEllipsize(TextUtils.TruncateAt.MARQUEE);\n        heading.setMarqueeRepeatLimit(-1);\n        heading.setSingleLine(true);\n        heading.setSelected(true);\n        heading.setTextColor(TEXT_COLOR);\n        heading.setTextSize(11.0f); //Better readability\n        heading.setGravity(Gravity.CENTER);\n        heading.setPadding(0, 0, 0, 8); //Better spacing for refined look\n        setHeadingText(heading);\n\n        //********** Mod menu feature list **********\n        scrollView = new ScrollView(this);\n        //Auto size. To set size manually, change the width and height example 500, 500\n        scrlLL = new LinearLayout.LayoutParams(MATCH_PARENT, dp(MENU_HEIGHT));\n        scrlLLExpanded = new LinearLayout.LayoutParams(mExpanded.getLayoutParams());\n        scrlLLExpanded.weight = 1.0f;\n        scrollView.setLayoutParams(Preferences.isExpanded ? scrlLLExpanded : scrlLL);\n        scrollView.setBackgroundColor(MENU_FEATURE_BG_COLOR);\n        patches = new LinearLayout(this);\n        patches.setOrientation(LinearLayout.VERTICAL);\n\n        //********** RelativeLayout for buttons **********\n        RelativeLayout relativeLayout = new RelativeLayout(this);\n        relativeLayout.setPadding(12, 6, 12, 6); //Consistent refined padding\n        relativeLayout.setVerticalGravity(Gravity.CENTER);\n\n        // Buttons removed for ImGui-style design\n\n        //********** Params **********\n        //Variable to check later if the phone supports Draw over other apps permission\n        int iparams = Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O ? 2038 : 2002;\n        params = new WindowManager.LayoutParams(WRAP_CONTENT, WRAP_CONTENT, iparams, 8, -3);\n        params.gravity = 51;\n        params.x = 0;\n        params.y = 80; //Slightly higher position for compact design\n\n        //********** Adding view components (ImGui Style) **********\n        rootFrame.addView(mRootContainer);\n        mRootContainer.addView(mCollapsed);\n        mRootContainer.addView(mThinBar); // Add thin bar for ImGui-style expansion\n        mRootContainer.addView(mExpanded);\n        if (IconWebViewData() != null) {\n            mCollapsed.addView(wView);\n        } else {\n            mCollapsed.addView(startimage);\n        }\n        titleText.addView(title);\n        titleText.addView(closeButton); // Updated to use close X button\n        mExpanded.addView(titleText);\n        mExpanded.addView(heading);\n        scrollView.addView(patches);\n        mExpanded.addView(scrollView);\n        // Buttons removed for clean ImGui-style design\n        mExpanded.addView(relativeLayout);\n        mWindowManager = (WindowManager) getSystemService(WINDOW_SERVICE);\n        mWindowManager.addView(rootFrame, params);\n\n        final Handler handler = new Handler();\n        handler.postDelayed(new Runnable() {\n            boolean viewLoaded = false;\n\n            @Override\n            public void run() {\n                //If the save preferences is enabled, it will check if game lib is loaded before starting menu\n                //Comment the if-else code out except startService if you want to run the app and test preferences\n                if (Preferences.loadPref && !isGameLibLoaded() && !stopChecking) {\n                    if (!viewLoaded) {\n                        patches.addView(Category(\"Save preferences was been enabled. Waiting for game lib to be loaded...\\n\\nForce load menu may not apply mods instantly. You would need to reactivate them again\"));\n                        patches.addView(Button(-100, \"Force load menu\"));\n                        viewLoaded = true;\n                    }\n                    handler.postDelayed(this, 600);\n                } else {\n                    patches.removeAllViews();\n                    featureList(getFeatureList(), patches);\n                }\n            }\n        }, 500);\n    }\n\n    private View.OnTouchListener onTouchListener() {\n        return new View.OnTouchListener() {\n            final View collapsedView = mCollapsed;\n            final View expandedView = mExpanded;\n            private float initialTouchX, initialTouchY;\n            private int initialX, initialY;\n\n            public boolean onTouch(View view, MotionEvent motionEvent) {\n                switch (motionEvent.getAction()) {\n                    case MotionEvent.ACTION_DOWN:\n                        initialX = params.x;\n                        initialY = params.y;\n                        initialTouchX = motionEvent.getRawX();\n                        initialTouchY = motionEvent.getRawY();\n                        return true;\n                    case MotionEvent.ACTION_UP:\n                        int rawX = (int) (motionEvent.getRawX() - initialTouchX);\n                        int rawY = (int) (motionEvent.getRawY() - initialTouchY);\n                        mExpanded.setAlpha(1f);\n                        mCollapsed.setAlpha(1f);\n                        //The check for Xdiff <10 && YDiff< 10 because sometime elements moves a little while clicking.\n                        //So that is click event.\n                        if (rawX < 10 && rawY < 10 && isViewCollapsed()) {\n                            //When user clicks on the image view of the collapsed layout,\n                            //visibility of the collapsed layout will be changed to \"View.GONE\"\n                            //and expanded view will become visible.\n                            try {\n                                collapsedView.setVisibility(View.GONE);\n                                expandedView.setVisibility(View.VISIBLE);\n                            } catch (NullPointerException e) {\n\n                            }\n                        }\n                        return true;\n                    case MotionEvent.ACTION_MOVE:\n                        mExpanded.setAlpha(0.5f);\n                        mCollapsed.setAlpha(0.5f);\n                        //Calculate the X and Y coordinates of the view.\n                        params.x = initialX + ((int) (motionEvent.getRawX() - initialTouchX));\n                        params.y = initialY + ((int) (motionEvent.getRawY() - initialTouchY));\n                        //Update the layout with new X & Y coordinate\n                        mWindowManager.updateViewLayout(rootFrame, params);\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        };\n    }\n\n    private void featureList(String[] listFT, LinearLayout linearLayout) {\n        //Currently looks messy right now. Let me know if you have improvements\n        int featNum, subFeat = 0;\n        LinearLayout llBak = linearLayout;\n\n        for (int i = 0; i < listFT.length; i++) {\n            boolean switchedOn = false;\n            //Log.i(\"featureList\", listFT[i]);\n            String feature = listFT[i];\n            if (feature.contains(\"True_\")) {\n                switchedOn = true;\n                feature = feature.replaceFirst(\"True_\", \"\");\n            }\n\n            linearLayout = llBak;\n            if (feature.contains(\"CollapseAdd_\")) {\n                //if (collapse != null)\n                linearLayout = mCollapse;\n                feature = feature.replaceFirst(\"CollapseAdd_\", \"\");\n            }\n            String[] str = feature.split(\"_\");\n\n            //Assign feature number\n            if (TextUtils.isDigitsOnly(str[0]) || str[0].matches(\"-[0-9]*\")) {\n                featNum = Integer.parseInt(str[0]);\n                feature = feature.replaceFirst(str[0] + \"_\", \"\");\n                subFeat++;\n            } else {\n                //Subtract feature number. We don't want to count ButtonLink, Category, RichTextView and RichWebView\n                featNum = i - subFeat;\n            }\n            String[] strSplit = feature.split(\"_\");\n            switch (strSplit[0]) {\n                case \"Toggle\":\n                    linearLayout.addView(Switch(featNum, strSplit[1], switchedOn));\n                    break;\n                case \"SeekBar\":\n                    linearLayout.addView(SeekBar(featNum, strSplit[1], Integer.parseInt(strSplit[2]), Integer.parseInt(strSplit[3])));\n                    break;\n                case \"Button\":\n                    linearLayout.addView(Button(featNum, strSplit[1]));\n                    break;\n                case \"ButtonOnOff\":\n                    linearLayout.addView(ButtonOnOff(featNum, strSplit[1], switchedOn));\n                    break;\n                case \"Spinner\":\n                    linearLayout.addView(RichTextView(strSplit[1]));\n                    linearLayout.addView(Spinner(featNum, strSplit[1], strSplit[2]));\n                    break;\n                case \"InputText\":\n                    linearLayout.addView(TextField(featNum, strSplit[1], false, 0));\n                    break;\n                case \"InputValue\":\n                    if (strSplit.length == 3)\n                        linearLayout.addView(TextField(featNum, strSplit[2], true, Integer.parseInt(strSplit[1])));\n                    if (strSplit.length == 2)\n                        linearLayout.addView(TextField(featNum, strSplit[1], true, 0));\n                    break;\n                case \"CheckBox\":\n                    linearLayout.addView(CheckBox(featNum, strSplit[1], switchedOn));\n                    break;\n                case \"RadioButton\":\n                    linearLayout.addView(RadioButton(featNum, strSplit[1], strSplit[2]));\n                    break;\n                case \"Collapse\":\n                    Collapse(linearLayout, strSplit[1]);\n                    subFeat++;\n                    break;\n                case \"ButtonLink\":\n                    subFeat++;\n                    linearLayout.addView(ButtonLink(strSplit[1], strSplit[2]));\n                    break;\n                case \"Category\":\n                    subFeat++;\n                    linearLayout.addView(Category(strSplit[1]));\n                    break;\n                case \"RichTextView\":\n                    subFeat++;\n                    linearLayout.addView(RichTextView(strSplit[1]));\n                    break;\n                case \"RichWebView\":\n                    subFeat++;\n                    linearLayout.addView(RichWebView(strSplit[1]));\n                    break;\n            }\n        }\n    }\n\n    private View Switch(final int featNum, final String featName, boolean swiOn) {\n        final Switch switchR = new Switch(this);\n        ColorStateList buttonStates = new ColorStateList(\n                new int[][]{\n                        new int[]{-android.R.attr.state_enabled},\n                        new int[]{android.R.attr.state_checked},\n                        new int[]{}\n                },\n                new int[]{\n                        Color.BLUE,\n                        ToggleON, // ON\n                        ToggleOFF // OFF\n                }\n        );\n        //Set colors of the switch. Comment out if you don't like it\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            switchR.getThumbDrawable().setTintList(buttonStates);\n            switchR.getTrackDrawable().setTintList(buttonStates);\n        }\n        switchR.setText(featName);\n        switchR.setTextColor(TEXT_COLOR_2);\n        switchR.setPadding(12, 6, 0, 6); //Premium consistent padding\n        switchR.setChecked(Preferences.loadPrefBool(featName, featNum, swiOn));\n        switchR.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            public void onCheckedChanged(CompoundButton compoundButton, boolean bool) {\n                Preferences.changeFeatureBool(featName, featNum, bool);\n                switch (featNum) {\n                    case -1: //Save perferences\n                        Preferences.with(switchR.getContext()).writeBoolean(-1, bool);\n                        if (bool == false)\n                            Preferences.with(switchR.getContext()).clear(); //Clear perferences if switched off\n                        break;\n                    case -3:\n                        Preferences.isExpanded = bool;\n                        scrollView.setLayoutParams(bool ? scrlLLExpanded : scrlLL);\n                        break;\n                }\n            }\n        });\n        return switchR;\n    }\n\n    private View SeekBar(final int featNum, final String featName, final int min, int max) {\n        int loadedProg = Preferences.loadPrefInt(featName, featNum);\n        LinearLayout linearLayout = new LinearLayout(this);\n        linearLayout.setPadding(10, 5, 0, 5);\n        linearLayout.setOrientation(LinearLayout.VERTICAL);\n        linearLayout.setGravity(Gravity.CENTER);\n\n        final TextView textView = new TextView(this);\n        textView.setText(Html.fromHtml(featName + \": <font color='\" + NumberTxtColor + \"'>\" + ((loadedProg == 0) ? min : loadedProg)));\n        textView.setTextColor(TEXT_COLOR_2);\n\n        SeekBar seekBar = new SeekBar(this);\n        seekBar.setPadding(25, 10, 35, 10);\n        seekBar.setMax(max);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)\n            seekBar.setMin(min); //setMin for Oreo and above\n        seekBar.setProgress((loadedProg == 0) ? min : loadedProg);\n        seekBar.getThumb().setColorFilter(SeekBarColor, PorterDuff.Mode.SRC_ATOP);\n        seekBar.getProgressDrawable().setColorFilter(SeekBarProgressColor, PorterDuff.Mode.SRC_ATOP);\n        seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n            public void onStartTrackingTouch(SeekBar seekBar) {\n            }\n\n            public void onStopTrackingTouch(SeekBar seekBar) {\n            }\n\n            public void onProgressChanged(SeekBar seekBar, int i, boolean z) {\n                //if progress is greater than minimum, don't go below. Else, set progress\n                seekBar.setProgress(i < min ? min : i);\n                Preferences.changeFeatureInt(featName, featNum, i < min ? min : i);\n                textView.setText(Html.fromHtml(featName + \": <font color='\" + NumberTxtColor + \"'>\" + (i < min ? min : i)));\n            }\n        });\n        linearLayout.addView(textView);\n        linearLayout.addView(seekBar);\n\n        return linearLayout;\n    }\n\n    private View Button(final int featNum, final String featName) {\n        final Button button = new Button(this);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);\n        layoutParams.setMargins(7, 5, 7, 5);\n        button.setLayoutParams(layoutParams);\n        button.setTextColor(TEXT_COLOR_2);\n        button.setAllCaps(false); //Disable caps to support html\n        button.setText(Html.fromHtml(featName));\n        button.setBackgroundColor(BTN_COLOR);\n        button.setOnClickListener(new View.OnClickListener() {\n            public void onClick(View v) {\n                switch (featNum) {\n                    case -4:\n                        Logcat.Save(getApplicationContext());\n                        break;\n                    case -5:\n                        Logcat.Clear(getApplicationContext());\n                        break;\n                    case -6:\n                        scrollView.removeView(mSettings);\n                        scrollView.addView(patches);\n                        break;\n                    case -100:\n                        stopChecking = true;\n                        break;\n                }\n                Preferences.changeFeatureInt(featName, featNum, 0);\n            }\n        });\n\n        return button;\n    }\n\n    private View ButtonLink(final String featName, final String url) {\n        final Button button = new Button(this);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);\n        layoutParams.setMargins(7, 5, 7, 5);\n        button.setLayoutParams(layoutParams);\n        button.setAllCaps(false); //Disable caps to support html\n        button.setTextColor(TEXT_COLOR_2);\n        button.setText(Html.fromHtml(featName));\n        button.setBackgroundColor(BTN_COLOR);\n        button.setOnClickListener(new View.OnClickListener() {\n            public void onClick(View v) {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                intent.setData(Uri.parse(url));\n                startActivity(intent);\n            }\n        });\n        return button;\n    }\n\n    private View ButtonOnOff(final int featNum, String featName, boolean switchedOn) {\n        final Button button = new Button(this);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);\n        layoutParams.setMargins(7, 5, 7, 5);\n        button.setLayoutParams(layoutParams);\n        button.setTextColor(TEXT_COLOR_2);\n        button.setAllCaps(false); //Disable caps to support html\n\n        final String finalfeatName = featName.replace(\"OnOff_\", \"\");\n        boolean isOn = Preferences.loadPrefBool(featName, featNum, switchedOn);\n        if (isOn) {\n            button.setText(Html.fromHtml(finalfeatName + \": ON\"));\n            button.setBackgroundColor(BtnON);\n            isOn = false;\n        } else {\n            button.setText(Html.fromHtml(finalfeatName + \": OFF\"));\n            button.setBackgroundColor(BtnOFF);\n            isOn = true;\n        }\n        final boolean finalIsOn = isOn;\n        button.setOnClickListener(new View.OnClickListener() {\n            boolean isOn = finalIsOn;\n\n            public void onClick(View v) {\n                Preferences.changeFeatureBool(finalfeatName, featNum, isOn);\n                //Log.d(TAG, finalfeatName + \" \" + featNum + \" \" + isActive2);\n                if (isOn) {\n                    button.setText(Html.fromHtml(finalfeatName + \": ON\"));\n                    button.setBackgroundColor(BtnON);\n                    isOn = false;\n                } else {\n                    button.setText(Html.fromHtml(finalfeatName + \": OFF\"));\n                    button.setBackgroundColor(BtnOFF);\n                    isOn = true;\n                }\n            }\n        });\n        return button;\n    }\n\n    private View Spinner(final int featNum, final String featName, final String list) {\n        Log.d(TAG, \"spinner \" + featNum + \" \" + featName + \" \" + list);\n        final List<String> lists = new LinkedList<>(Arrays.asList(list.split(\",\")));\n\n        // Create another LinearLayout as a workaround to use it as a background\n        // to keep the down arrow symbol. No arrow symbol if setBackgroundColor set\n        LinearLayout linearLayout2 = new LinearLayout(this);\n        LinearLayout.LayoutParams layoutParams2 = new LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT);\n        layoutParams2.setMargins(7, 2, 7, 5);\n        linearLayout2.setOrientation(LinearLayout.VERTICAL);\n        linearLayout2.setBackgroundColor(BTN_COLOR);\n        linearLayout2.setLayoutParams(layoutParams2);\n\n        final Spinner spinner = new Spinner(this, Spinner.MODE_DROPDOWN);\n        spinner.setLayoutParams(layoutParams2);\n        spinner.getBackground().setColorFilter(1, PorterDuff.Mode.SRC_ATOP); //trick to show white down arrow color\n        //Creating the ArrayAdapter instance having the list\n        ArrayAdapter aa = new ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, lists);\n        aa.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n        //Setting the ArrayAdapter data on the Spinner'\n        spinner.setAdapter(aa);\n        spinner.setSelection(Preferences.loadPrefInt(featName, featNum));\n        spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n            @Override\n            public void onItemSelected(AdapterView<?> parentView, View selectedItemView, int position, long id) {\n                Preferences.changeFeatureInt(spinner.getSelectedItem().toString(), featNum, position);\n                ((TextView) parentView.getChildAt(0)).setTextColor(TEXT_COLOR_2);\n            }\n\n            @Override\n            public void onNothingSelected(AdapterView<?> parent) {\n            }\n        });\n        linearLayout2.addView(spinner);\n        return linearLayout2;\n    }\n\n    private View TextField(final int featNum, final String featName, final boolean numOnly, final int maxValue) {\n        final EditTextString edittextstring = new EditTextString();\n        final EditTextNum edittextnum = new EditTextNum();\n        LinearLayout linearLayout = new LinearLayout(this);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);\n        layoutParams.setMargins(7, 5, 7, 5);\n\n        final Button button = new Button(this);\n        if (numOnly) {\n            int num = Preferences.loadPrefInt(featName, featNum);\n            edittextnum.setNum((num == 0) ? 1 : num);\n            button.setText(Html.fromHtml(featName + \": <font color='\" + NumberTxtColor + \"'>\" + ((num == 0) ? 1 : num) + \"</font>\"));\n        } else {\n            String string = Preferences.loadPrefString(featName, featNum);\n            edittextstring.setString((string == \"\") ? \"\" : string);\n            button.setText(Html.fromHtml(featName + \": <font color='\" + NumberTxtColor + \"'>\" + string + \"</font>\"));\n        }\n        button.setAllCaps(false);\n        button.setLayoutParams(layoutParams);\n        button.setBackgroundColor(BTN_COLOR);\n        button.setTextColor(TEXT_COLOR_2);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                final AlertDialog alert = new AlertDialog.Builder(getApplicationContext(), 2).create();\n                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n                    Objects.requireNonNull(alert.getWindow()).setType(Build.VERSION.SDK_INT >= 26 ? 2038 : 2002);\n                }\n                alert.setOnCancelListener(new DialogInterface.OnCancelListener() {\n                    public void onCancel(DialogInterface dialog) {\n                        InputMethodManager imm = (InputMethodManager) getSystemService(getApplicationContext().INPUT_METHOD_SERVICE);\n                        imm.toggleSoftInput(InputMethodManager.HIDE_IMPLICIT_ONLY, 0);\n                    }\n                });\n\n                //LinearLayout\n                LinearLayout linearLayout1 = new LinearLayout(getApplicationContext());\n                linearLayout1.setPadding(5, 5, 5, 5);\n                linearLayout1.setOrientation(LinearLayout.VERTICAL);\n                linearLayout1.setBackgroundColor(MENU_FEATURE_BG_COLOR);\n\n                //TextView\n                final TextView TextViewNote = new TextView(getApplicationContext());\n                TextViewNote.setText(\"Tap OK to apply changes. Tap outside to cancel\");\n                if (maxValue != 0)\n                TextViewNote.setText(\"Tap OK to apply changes. Tap outside to cancel\\nMax value: \" + maxValue);\n                TextViewNote.setTextColor(TEXT_COLOR_2);\n\n                //Edit text\n                final EditText edittext = new EditText(getApplicationContext());\n                edittext.setMaxLines(1);\n                edittext.setWidth(convertDipToPixels(300));\n                edittext.setTextColor(TEXT_COLOR_2);\n                if (numOnly) {\n                    edittext.setInputType(InputType.TYPE_CLASS_NUMBER);\n                    edittext.setKeyListener(DigitsKeyListener.getInstance(\"0123456789-\"));\n                    InputFilter[] FilterArray = new InputFilter[1];\n                    FilterArray[0] = new InputFilter.LengthFilter(10);\n                    edittext.setFilters(FilterArray);\n                } else {\n                    edittext.setText(edittextstring.getString());\n                }\n                edittext.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n                    @Override\n                    public void onFocusChange(View v, boolean hasFocus) {\n                        InputMethodManager imm = (InputMethodManager) getSystemService(getApplicationContext().INPUT_METHOD_SERVICE);\n                        if (hasFocus) {\n                            imm.toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                        } else {\n                            imm.toggleSoftInput(InputMethodManager.HIDE_IMPLICIT_ONLY, 0);\n                        }\n                    }\n                });\n                edittext.requestFocus();\n\n                //Button\n                Button btndialog = new Button(getApplicationContext());\n                btndialog.setBackgroundColor(BTN_COLOR);\n                btndialog.setTextColor(TEXT_COLOR_2);\n                btndialog.setText(\"OK\");\n                btndialog.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        if (numOnly) {\n                            int num;\n                            try {\n                                num = Integer.parseInt(TextUtils.isEmpty(edittext.getText().toString()) ? \"0\" : edittext.getText().toString());\n                                if (maxValue != 0 &&  num >= maxValue)\n                                    num = maxValue;\n                            } catch (NumberFormatException ex) {\n                                num = 2147483640;\n                            }\n                            edittextnum.setNum(num);\n                            button.setText(Html.fromHtml(featName + \": <font color='\" + NumberTxtColor + \"'>\" + num + \"</font>\"));\n                            alert.dismiss();\n                            Preferences.changeFeatureInt(featName, featNum, num);\n                        } else {\n                            String str = edittext.getText().toString();\n                            edittextstring.setString(edittext.getText().toString());\n                            button.setText(Html.fromHtml(featName + \": <font color='\" + NumberTxtColor + \"'>\" + str + \"</font>\"));\n                            alert.dismiss();\n                            Preferences.changeFeatureString(featName, featNum, str);\n                        }\n                        edittext.setFocusable(false);\n                    }\n                });\n\n                linearLayout1.addView(TextViewNote);\n                linearLayout1.addView(edittext);\n                linearLayout1.addView(btndialog);\n                alert.setView(linearLayout1);\n                alert.show();\n            }\n        });\n\n        linearLayout.addView(button);\n        return linearLayout;\n    }\n\n    private View CheckBox(final int featNum, final String featName, boolean switchedOn) {\n        final CheckBox checkBox = new CheckBox(this);\n        checkBox.setText(featName);\n        checkBox.setTextColor(TEXT_COLOR_2);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n            checkBox.setButtonTintList(ColorStateList.valueOf(CheckBoxColor));\n        checkBox.setChecked(Preferences.loadPrefBool(featName, featNum, switchedOn));\n        checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n                if (checkBox.isChecked()) {\n                    Preferences.changeFeatureBool(featName, featNum, isChecked);\n                } else {\n                    Preferences.changeFeatureBool(featName, featNum, isChecked);\n                }\n            }\n        });\n        return checkBox;\n    }\n\n    private View RadioButton(final int featNum, String featName, final String list) {\n        //Credit: LoraZalora\n        final List<String> lists = new LinkedList<>(Arrays.asList(list.split(\",\")));\n\n        final TextView textView = new TextView(this);\n        textView.setText(featName + \":\");\n        textView.setTextColor(TEXT_COLOR_2);\n\n        final RadioGroup radioGroup = new RadioGroup(this);\n        radioGroup.setPadding(10, 5, 10, 5);\n        radioGroup.setOrientation(LinearLayout.VERTICAL);\n        radioGroup.addView(textView);\n\n        for (int i = 0; i < lists.size(); i++) {\n            final RadioButton Radioo = new RadioButton(this);\n            final String finalfeatName = featName, radioName = lists.get(i);\n            View.OnClickListener first_radio_listener = new View.OnClickListener() {\n                public void onClick(View v) {\n                    textView.setText(Html.fromHtml(finalfeatName + \": <font color='\" + NumberTxtColor + \"'>\" + radioName));\n                    Preferences.changeFeatureInt(finalfeatName, featNum, radioGroup.indexOfChild(Radioo));\n                }\n            };\n            System.out.println(lists.get(i));\n            Radioo.setText(lists.get(i));\n            Radioo.setTextColor(Color.LTGRAY);\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n                Radioo.setButtonTintList(ColorStateList.valueOf(RadioColor));\n            Radioo.setOnClickListener(first_radio_listener);\n            radioGroup.addView(Radioo);\n        }\n\n        int index = Preferences.loadPrefInt(featName, featNum);\n        if (index > 0) { //Preventing it to get an index less than 1. below 1 = null = crash\n            textView.setText(Html.fromHtml(featName + \": <font color='\" + NumberTxtColor + \"'>\" + lists.get(index - 1)));\n            ((RadioButton) radioGroup.getChildAt(index)).setChecked(true);\n        }\n\n        return radioGroup;\n    }\n\n    private void Collapse(LinearLayout linLayout, final String text) {\n        LinearLayout.LayoutParams layoutParamsLL = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);\n        layoutParamsLL.setMargins(0, 5, 0, 0);\n\n        LinearLayout collapse = new LinearLayout(this);\n        collapse.setLayoutParams(layoutParamsLL);\n        collapse.setVerticalGravity(16);\n        collapse.setOrientation(LinearLayout.VERTICAL);\n\n        final LinearLayout collapseSub = new LinearLayout(this);\n        collapseSub.setVerticalGravity(16);\n        collapseSub.setPadding(0, 5, 0, 5);\n        collapseSub.setOrientation(LinearLayout.VERTICAL);\n        collapseSub.setBackgroundColor(Color.parseColor(\"#222D38\"));\n        collapseSub.setVisibility(View.GONE);\n        mCollapse = collapseSub;\n\n        final TextView textView = new TextView(this);\n        textView.setBackgroundColor(CategoryBG);\n        textView.setText(\"▽ \" + text + \" ▽\");\n        textView.setGravity(Gravity.CENTER);\n        textView.setTextColor(TEXT_COLOR_2);\n        textView.setTypeface(null, Typeface.BOLD);\n        textView.setPadding(0, 20, 0, 20);\n        textView.setOnClickListener(new View.OnClickListener() {\n            boolean isChecked;\n\n            @Override\n            public void onClick(View v) {\n\n                boolean z = !this.isChecked;\n                this.isChecked = z;\n                if (z) {\n                    collapseSub.setVisibility(View.VISIBLE);\n                    textView.setText(\"△ \" + text + \" △\");\n                    return;\n                }\n                collapseSub.setVisibility(View.GONE);\n                textView.setText(\"▽ \" + text + \" ▽\");\n            }\n        });\n        collapse.addView(textView);\n        collapse.addView(collapseSub);\n        linLayout.addView(collapse);\n    }\n\n    private View Category(String text) {\n        TextView textView = new TextView(this);\n        textView.setBackgroundColor(CategoryBG);\n        textView.setText(Html.fromHtml(text));\n        textView.setGravity(Gravity.CENTER);\n        textView.setTextColor(TEXT_COLOR_2);\n        textView.setTypeface(null, Typeface.BOLD);\n        textView.setPadding(0, 5, 0, 5);\n        return textView;\n    }\n\n    private View RichTextView(String text) {\n        TextView textView = new TextView(this);\n        textView.setText(Html.fromHtml(text));\n        textView.setTextColor(TEXT_COLOR_2);\n        textView.setPadding(10, 5, 10, 5);\n        return textView;\n    }\n\n    private View RichWebView(String text) {\n        WebView wView = new WebView(this);\n        wView.loadData(text, \"text/html\", \"utf-8\");\n        wView.setBackgroundColor(0x00000000); //Transparent\n        wView.setPadding(0, 5, 0, 5);\n        wView.getSettings().setAppCacheEnabled(false);\n        return wView;\n    }\n\n    //Override our Start Command so the Service doesnt try to recreate itself when the App is closed\n    public int onStartCommand(Intent intent, int i, int i2) {\n        return Service.START_NOT_STICKY;\n    }\n\n    private boolean isViewCollapsed() {\n        return rootFrame == null || mCollapsed.getVisibility() == View.VISIBLE;\n    }\n\n    //For our image a little converter\n    private int convertDipToPixels(int i) {\n        return (int) ((((float) i) * getResources().getDisplayMetrics().density) + 0.5f);\n    }\n\n    private int dp(int i) {\n        return (int) TypedValue.applyDimension(1, (float) i, getResources().getDisplayMetrics());\n    }\n\n    //Check if we are still in the game. If now our menu and menu button will dissapear\n    private boolean isNotInGame() {\n        RunningAppProcessInfo runningAppProcessInfo = new RunningAppProcessInfo();\n        ActivityManager.getMyMemoryState(runningAppProcessInfo);\n        return runningAppProcessInfo.importance != 100;\n    }\n\n    //Destroy our View\n    public void onDestroy() {\n        super.onDestroy();\n        if (rootFrame != null) {\n            mWindowManager.removeView(rootFrame);\n        }\n    }\n\n    //Same as above so it wont crash in the background and therefore use alot of Battery life\n    public void onTaskRemoved(Intent intent) {\n        super.onTaskRemoved(intent);\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        stopSelf();\n    }\n\n    private void Thread() {\n        if (rootFrame == null) {\n            return;\n        }\n        if (isNotInGame()) {\n            rootFrame.setVisibility(View.INVISIBLE);\n        } else {\n            rootFrame.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private class EditTextString {\n        private String text;\n\n        public void setString(String s) {\n            text = s;\n        }\n\n        public String getString() {\n            return text;\n        }\n    }\n\n    private class EditTextNum {\n        private int val;\n\n        public void setNum(int i) {\n            val = i;\n        }\n\n        public int getNum() {\n            return val;\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n}","size_bytes":46649},"app/src/main/java/uk/lgl/modmenu/Logcat.java":{"content":"package uk.lgl.modmenu;\n\nimport android.content.Context;\nimport android.os.Build;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Logcat {\n    public static void Clear(Context context) {\n        try {\n            Runtime.getRuntime().exec(\"logcat -c\");\n            Toast.makeText(context, \"Logcat cleared\", Toast.LENGTH_LONG).show();\n        } catch (IOException e) {\n            Toast.makeText(context, \"There was an error saving logcat to file\", Toast.LENGTH_LONG).show();\n            e.printStackTrace();\n        }\n    }\n\n    public static void Save(Context context) {\n        File path = null;\n        try {\n            Process process = Runtime.getRuntime().exec(\"logcat -d\");\n            BufferedReader bufferedReader = new BufferedReader(\n                    new InputStreamReader(process.getInputStream()));\n\n            StringBuilder log = new StringBuilder();\n            String line = \"\";\n            while ((line = bufferedReader.readLine()) != null) {\n                log.append(line + \"\\n\");\n            }\n            long unixTime = System.currentTimeMillis() / 1000L;\n            if (Build.VERSION.SDK_INT >= 30) { //Android R. AIDE didn't support Build.VERSION_CODES.R\n                path = new File(\"/storage/emulated/0/Documents/\");\n            } else {\n                path = new File(context.getExternalFilesDir(null) + \"/Mod Menu\");\n            }\n\n            File folder = new File(String.valueOf(path));\n            folder.mkdirs();\n\n            File file = new File(path + \"/Mod menu log - \" + context.getPackageName() + \".txt\");\n            file.createNewFile();\n\n            try {\n                //BufferedWriter for performance, true to set append to file flag\n                BufferedWriter buf = new BufferedWriter(new FileWriter(file));\n                buf.append(log.toString());\n                buf.newLine();\n                buf.close();\n                Toast.makeText(context, \"Logcat saved successfully to: \" + file.toString(), Toast.LENGTH_LONG).show();\n                Toast.makeText(context, \"Logcat saved successfully to: \" + file.toString(), Toast.LENGTH_LONG).show();\n            } catch (IOException e) {\n                Toast.makeText(context, \"There was an error saving logcat to file: \" + e.getLocalizedMessage(), Toast.LENGTH_LONG).show();\n                e.printStackTrace();\n            }\n        } catch (IOException e) {\n            Toast.makeText(context, \"There was an error saving logcat to file: \" + Log.getStackTraceString(e), Toast.LENGTH_LONG).show();\n            e.printStackTrace();\n        }\n    }\n}\n","size_bytes":2756},"app/src/main/java/uk/lgl/modmenu/Preferences.java":{"content":"package uk.lgl.modmenu;\n\nimport android.annotation.TargetApi;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.util.Log;\nimport android.os.Build;\n\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport static android.preference.PreferenceManager.getDefaultSharedPreferences;\n\npublic class Preferences {\n    private static SharedPreferences sharedPreferences;\n    private static Preferences prefsInstance;\n    public static Context context;\n    public static boolean loadPref, isExpanded;\n\n    private static final String LENGTH = \"_length\";\n    private static final String DEFAULT_STRING_VALUE = \"\";\n    private static final int DEFAULT_INT_VALUE = 0; //-1\n    private static final double DEFAULT_DOUBLE_VALUE = 0d; //-1d\n    private static final float DEFAULT_FLOAT_VALUE = 0f; //-1f\n    private static final long DEFAULT_LONG_VALUE = 0L; //-1L\n    private static final boolean DEFAULT_BOOLEAN_VALUE = false;\n\n    public static native void Changes(Context con, int fNum, String fName, int i, boolean bool, String str);\n\n    public static void changeFeatureInt(String featureName, int featureNum, int value) {\n        Preferences.with(context).writeInt(featureNum, value);\n        Changes(context, featureNum, featureName, value, false, null);\n    }\n\n    public static void changeFeatureString(String featureName, int featureNum, String str) {\n        Preferences.with(context).writeString(featureNum, str);\n        Changes(context, featureNum, featureName, 0, false, str);\n    }\n\n    public static void changeFeatureBool(String featureName, int featureNum, boolean bool) {\n        Preferences.with(context).writeBoolean(featureNum, bool);\n        Changes(context, featureNum, featureName, 0, bool, null);\n    }\n\n    public static int loadPrefInt(String featureName, int featureNum) {\n        if (loadPref) {\n            int i = Preferences.with(context).readInt(featureNum);\n            Changes(context, featureNum, featureName, i, false, null);\n            return i;\n        }\n        return 0;\n    }\n\n    public static boolean loadPrefBool(String featureName, int featureNum, boolean bDef) {\n        boolean bool = Preferences.with(context).readBoolean(featureNum, bDef);\n        if (featureNum == -1) {\n            loadPref = bool;\n        }\n        if (featureNum == -3) {\n            isExpanded = bool;\n        }\n        if (loadPref || featureNum < 0) {\n            bDef = bool;\n        }\n\n        Changes(context, featureNum, featureName, 0, bDef, null);\n        return bDef;\n    }\n\n    public static String loadPrefString(String featureName, int featureNum) {\n        if (loadPref || featureNum <= 0) {\n            String str = Preferences.with(context).readString(featureNum);\n            Changes(context, featureNum, featureName, 0, false, str);\n            return str;\n        }\n        return \"\";\n    }\n\n    private Preferences(Context context) {\n        sharedPreferences = context.getApplicationContext().getSharedPreferences(\n                context.getPackageName() + \"_preferences\",\n                Context.MODE_PRIVATE\n        );\n    }\n\n    private Preferences(Context context, String preferencesName) {\n        sharedPreferences = context.getApplicationContext().getSharedPreferences(\n                preferencesName,\n                Context.MODE_PRIVATE\n        );\n    }\n\n    /**\n     * @param context\n     * @return Returns a 'Preferences' instance\n     */\n    public static Preferences with(Context context) {\n        if (prefsInstance == null) {\n            prefsInstance = new Preferences(context);\n        }\n        return prefsInstance;\n    }\n\n    /**\n     * @param context\n     * @param forceInstantiation\n     * @return Returns a 'Preferences' instance\n     */\n    public static Preferences with(Context context, boolean forceInstantiation) {\n        if (forceInstantiation) {\n            prefsInstance = new Preferences(context);\n        }\n        return prefsInstance;\n    }\n\n    /**\n     * @param context\n     * @param preferencesName\n     * @return Returns a 'Preferences' instance\n     */\n    public static Preferences with(Context context, String preferencesName) {\n        if (prefsInstance == null) {\n            prefsInstance = new Preferences(context, preferencesName);\n        }\n        return prefsInstance;\n    }\n\n    /**\n     * @param context\n     * @param preferencesName\n     * @param forceInstantiation\n     * @return Returns a 'Preferences' instance\n     */\n    public static Preferences with(Context context, String preferencesName,\n                                   boolean forceInstantiation) {\n        if (forceInstantiation) {\n            prefsInstance = new Preferences(context, preferencesName);\n        }\n        return prefsInstance;\n    }\n\n    // String related methods\n\n    /**\n     * @param what\n     * @return Returns the stored value of 'what'\n     */\n    public String readString(String what) {\n        return sharedPreferences.getString(what, DEFAULT_STRING_VALUE);\n    }\n\n    /**\n     * @param what\n     * @return Returns the stored value of 'what'\n     */\n    public String readString(int what) {\n        try {\n            return sharedPreferences.getString(String.valueOf(what), DEFAULT_STRING_VALUE);\n        } catch (java.lang.ClassCastException ex) {\n            return \"\";\n        }\n    }\n\n    /**\n     * @param what\n     * @param defaultString\n     * @return Returns the stored value of 'what'\n     */\n    public String readString(String what, String defaultString) {\n        return sharedPreferences.getString(what, defaultString);\n    }\n\n    /**\n     * @param where\n     * @param what\n     */\n    public void writeString(String where, String what) {\n        sharedPreferences.edit().putString(where, what).apply();\n    }\n\n    /**\n     * @param where\n     * @param what\n     */\n    public void writeString(int where, String what) {\n        sharedPreferences.edit().putString(String.valueOf(where), what).apply();\n    }\n\n    // int related methods\n\n    /**\n     * @param what\n     * @return Returns the stored value of 'what'\n     */\n    public int readInt(String what) {\n        return sharedPreferences.getInt(what, DEFAULT_INT_VALUE);\n    }\n\n\n    /**\n     * @param what\n     * @return Returns the stored value of 'what'\n     */\n    public int readInt(int what) {\n        try {\n            return sharedPreferences.getInt(String.valueOf(what), DEFAULT_INT_VALUE);\n        } catch (java.lang.ClassCastException ex) {\n            return 0;\n        }\n    }\n\n    /**\n     * @param what\n     * @param defaultInt\n     * @return Returns the stored value of 'what'\n     */\n    public int readInt(String what, int defaultInt) {\n        return sharedPreferences.getInt(what, defaultInt);\n    }\n\n    /**\n     * @param where\n     * @param what\n     */\n    public void writeInt(String where, int what) {\n        sharedPreferences.edit().putInt(where, what).apply();\n    }\n\n    /**\n     * @param where\n     * @param what\n     */\n    public void writeInt(int where, int what) {\n        sharedPreferences.edit().putInt(String.valueOf(where), what).apply();\n    }\n\n    // double related methods\n\n    /**\n     * @param what\n     * @return Returns the stored value of 'what'\n     */\n    public double readDouble(String what) {\n        if (!contains(what))\n            return DEFAULT_DOUBLE_VALUE;\n        return Double.longBitsToDouble(readLong(what));\n    }\n\n    /**\n     * @param what\n     * @param defaultDouble\n     * @return Returns the stored value of 'what'\n     */\n    public double readDouble(String what, double defaultDouble) {\n        if (!contains(what))\n            return defaultDouble;\n        return Double.longBitsToDouble(readLong(what));\n    }\n\n    /**\n     * @param where\n     * @param what\n     */\n    public void writeDouble(String where, double what) {\n        writeLong(where, Double.doubleToRawLongBits(what));\n    }\n\n    // float related methods\n\n    /**\n     * @param what\n     * @return Returns the stored value of 'what'\n     */\n    public float readFloat(String what) {\n        return sharedPreferences.getFloat(what, DEFAULT_FLOAT_VALUE);\n    }\n\n    /**\n     * @param what\n     * @param defaultFloat\n     * @return Returns the stored value of 'what'\n     */\n    public float readFloat(String what, float defaultFloat) {\n        return sharedPreferences.getFloat(what, defaultFloat);\n    }\n\n    /**\n     * @param where\n     * @param what\n     */\n    public void writeFloat(String where, float what) {\n        sharedPreferences.edit().putFloat(where, what).apply();\n    }\n\n    // long related methods\n\n    /**\n     * @param what\n     * @return Returns the stored value of 'what'\n     */\n    public long readLong(String what) {\n        return sharedPreferences.getLong(what, DEFAULT_LONG_VALUE);\n    }\n\n    /**\n     * @param what\n     * @param defaultLong\n     * @return Returns the stored value of 'what'\n     */\n    public long readLong(String what, long defaultLong) {\n        return sharedPreferences.getLong(what, defaultLong);\n    }\n\n    /**\n     * @param where\n     * @param what\n     */\n    public void writeLong(String where, long what) {\n        sharedPreferences.edit().putLong(where, what).apply();\n    }\n\n    // boolean related methods\n\n    /**\n     * @param what\n     * @return Returns the stored value of 'what'\n     */\n    public boolean readBoolean(String what) {\n        return sharedPreferences.getBoolean(what, DEFAULT_BOOLEAN_VALUE);\n    }\n\n    /**\n     * @param what\n     * @return Returns the stored value of 'what'\n     */\n    public boolean readBoolean(int what) {\n        return sharedPreferences.getBoolean(String.valueOf(what), DEFAULT_BOOLEAN_VALUE);\n    }\n\n    /**\n     * @param what\n     * @param defaultBoolean\n     * @return Returns the stored value of 'what'\n     */\n    public boolean readBoolean(String what, boolean defaultBoolean) {\n        /*if (defaultBoolean == true && !sharedPreferences.contains(what))\n            writeBoolean(what, true);*/\n        return sharedPreferences.getBoolean(what, defaultBoolean);\n    }\n\n    /**\n     * @param what\n     * @param defaultBoolean\n     * @return Returns the stored value of 'what'\n     */\n    public boolean readBoolean(int what, boolean defaultBoolean) {\n        /*if (defaultBoolean == true && !sharedPreferences.contains(String.valueOf(what)))\n            writeBoolean(what, true);*/\n        try {\n            return sharedPreferences.getBoolean(String.valueOf(what), defaultBoolean);\n        } catch (java.lang.ClassCastException ex) {\n            return defaultBoolean;\n        }\n    }\n\n    /**\n     * @param where\n     * @param what\n     */\n    public void writeBoolean(String where, boolean what) {\n        sharedPreferences.edit().putBoolean(where, what).apply();\n    }\n\n    /**\n     * @param where\n     * @param what\n     */\n    public void writeBoolean(int where, boolean what) {\n        sharedPreferences.edit().putBoolean(String.valueOf(where), what).apply();\n    }\n\n    // String set methods\n\n    /**\n     * @param key\n     * @param value\n     */\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB)\n    public void putStringSet(final String key, final Set<String> value) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n            sharedPreferences.edit().putStringSet(key, value).apply();\n        } else {\n            // Workaround for pre-HC's lack of StringSets\n            putOrderedStringSet(key, value);\n        }\n    }\n\n    /**\n     * @param key\n     * @param value\n     */\n    public void putOrderedStringSet(String key, Set<String> value) {\n        int stringSetLength = 0;\n        if (sharedPreferences.contains(key + LENGTH)) {\n            // First read what the value was\n            stringSetLength = readInt(key + LENGTH);\n        }\n        writeInt(key + LENGTH, value.size());\n        int i = 0;\n        for (String aValue : value) {\n            writeString(key + \"[\" + i + \"]\", aValue);\n            i++;\n        }\n        for (; i < stringSetLength; i++) {\n            // Remove any remaining values\n            remove(key + \"[\" + i + \"]\");\n        }\n    }\n\n    /**\n     * @param key\n     * @param defValue\n     * @return Returns the String Set with HoneyComb compatibility\n     */\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB)\n    public Set<String> getStringSet(final String key, final Set<String> defValue) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n            return sharedPreferences.getStringSet(key, defValue);\n        } else {\n            // Workaround for pre-HC's missing getStringSet\n            return getOrderedStringSet(key, defValue);\n        }\n    }\n\n    /**\n     * @param key\n     * @param defValue\n     * @return Returns the ordered String Set\n     */\n    public Set<String> getOrderedStringSet(String key, final Set<String> defValue) {\n        if (contains(key + LENGTH)) {\n            LinkedHashSet<String> set = new LinkedHashSet<>();\n            int stringSetLength = readInt(key + LENGTH);\n            if (stringSetLength >= 0) {\n                for (int i = 0; i < stringSetLength; i++) {\n                    set.add(readString(key + \"[\" + i + \"]\"));\n                }\n            }\n            return set;\n        }\n        return defValue;\n    }\n\n    // end related methods\n\n    /**\n     * @param key\n     */\n    public void remove(final String key) {\n        if (contains(key + LENGTH)) {\n            // Workaround for pre-HC's lack of StringSets\n            int stringSetLength = readInt(key + LENGTH);\n            if (stringSetLength >= 0) {\n                sharedPreferences.edit().remove(key + LENGTH).apply();\n                for (int i = 0; i < stringSetLength; i++) {\n                    sharedPreferences.edit().remove(key + \"[\" + i + \"]\").apply();\n                }\n            }\n        }\n        sharedPreferences.edit().remove(key).apply();\n    }\n\n    /**\n     * @param key\n     * @return Returns if that key exists\n     */\n    public boolean contains(final String key) {\n        return sharedPreferences.contains(key);\n    }\n\n    /**\n     * Clear all the preferences\n     */\n    public void clear() {\n        sharedPreferences.edit().clear().apply();\n    }\n}","size_bytes":14137}},"version":1}